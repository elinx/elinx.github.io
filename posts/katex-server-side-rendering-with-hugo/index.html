<!doctype html><html lang=en><head><title>Katex Server Side Rendering With Hugo :: Collate, Summarize & Explain</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="将$\KaTeX$引入到Hugo里边几乎不费什么力气，并且能得到很好的显示效果和性能。但是如果文件比较大的时候就很糟心了，每次重新加载都要重"><meta name=keywords content="Hugo,Katex,Server Side Rendering,Client Side Rendering,服务端渲染,客户端渲染"><meta name=robots content="noodp"><link rel=canonical href=https://elinx.github.io/posts/katex-server-side-rendering-with-hugo/><script async src="https://www.googletagmanager.com/gtag/js?id=G-ME978TCHX2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ME978TCHX2",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://elinx.github.io/assets/style.css><link rel=stylesheet href=https://elinx.github.io/style.css><link rel=apple-touch-icon href=https://elinx.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://elinx.github.io/favicon.ico><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Katex Server Side Rendering With Hugo"><meta property="og:description" content="将$\KaTeX$引入到Hugo里边几乎不费什么力气，并且能得到很好的显示效果和性能。但是如果文件比较大的时候就很糟心了，每次重新加载都要重"><meta property="og:url" content="https://elinx.github.io/posts/katex-server-side-rendering-with-hugo/"><meta property="og:site_name" content="Collate, Summarize & Explain"><meta property="og:image" content="https://elinx.github.io/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-11-11 20:24:10 +0800 +0800"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{"\\pdiff":"\\frac{\\partial{#1}}{\\partial{#2}}","\\nlspc":"\\\\[0.5em]","\\empsym":"{\\color{##ffa86a}{#1}}"}})})</script></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://elinx.github.io/><div class=logo>xi</div></a></div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://elinx.github.io/posts/katex-server-side-rendering-with-hugo/>Katex Server Side Rendering With Hugo</a></h1><div class=post-meta><span class=post-date>2022-11-11
[Updated: 2022-11-20]</span>
<span class=post-reading-time>:: 4 min read (1791 words)</span></div><span class=post-tags>#<a href=https://elinx.github.io/tags/hugo/>Hugo</a>&nbsp;
#<a href=https://elinx.github.io/tags/katex/>Katex</a>&nbsp;
#<a href=https://elinx.github.io/tags/server-side-rendering/>Server Side Rendering</a>&nbsp;
#<a href=https://elinx.github.io/tags/client-side-rendering/>Client Side Rendering</a>&nbsp;
#<a href=https://elinx.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/>服务端渲染</a>&nbsp;
#<a href=https://elinx.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/>客户端渲染</a>&nbsp;</span><div class=post-content><div><p>将$\KaTeX$引入到Hugo里边几乎不费什么力气，并且能得到很好的显示效果和性能。但是如果文件比较大的时候就很糟心了，每次重新加载都要重新渲染，在一般配置的电脑上加载<a href=https://elinx.github.io/posts/deep-learning-matrix-calculus/>这篇公式较多的文章</a>的时候要耗时10s以上。</p><p>分析了一下加载的流程，Katex的渲染以及js脚本的下载都占用了不少的时间。这是因为使用的是Client Side的渲染方法，要先下载js再处理数学公式的内容，每次加载都要如此，那能不能在Server Side直接渲染呢，尤其是在Hugo这静态网站上面Once for All？</p><p>这篇文章<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>比较详细的综述了到目前为止(2022年)Katex在Server Side的渲染情况，主要有几种解决方法：</p><ul><li>让Hugo使用一个goldmark扩展，在这个扩展里边渲染Katex，目前仅有的是<code>goldmark-qjs-katex</code>，但是这个扩展因为有不可移植代码的原因压根就没有被上游接受，不得已其作者自己fork了一份Hugo，但是似乎又没有精力维护跟上游版本的同步<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，导致落后Hugo不少版本。</li><li>Hugo是支持pandoc的，而pandoc是支持Katex渲染的，也就意味着文档的格式要用pandoc来写，这篇文章<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>记录了这个过程。</li><li>或者尝试直接将扩展写到Hugo里边，但是并没有真正的在做Server Side渲染</li></ul><p>上面的方法都是努力将渲染的过程集成到Hugo当中去，实现无缝的工作流，但是这个目标目前看来还很难实现。 作者花了很多的时间去调研，最后不得已使用了Client Side的渲染方式，看起来也是相当的无奈。</p><p>如果改变不了Hugo又不想切换其他工具的话，那就只能改变自己了。</p><p>事实上，考虑到直接调用<code>katex.renderToString</code>就可以生成html，我们拿到Hugo输出html文件的后可以在自己的workflow上面加一个后处理的stage来完成替换就可以了。这是因为数学公式是以<code>$</code>分割的，如果我们能定位到这些内容，用一些替换规则就可以完成简单的渲染了。</p><p>这里选择使用正则表达式匹配到<code>$</code>中间的内容，然后调用Katex的函数生成html再替换原来的内容，注意这部分的配置要跟Client Side渲染的参数完全一样才能达到一致的效果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>delimiters</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>left</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;$$&#34;</span>, <span style=color:#a6e22e>right</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;$$&#34;</span>, <span style=color:#a6e22e>display</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span> },
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>left</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;$&#34;</span>, <span style=color:#a6e22e>right</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;$&#34;</span>, <span style=color:#a6e22e>display</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span> },
</span></span><span style=display:flex><span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>delim</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>delimiters</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>regex</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RegExp(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>escapeRegex</span>(<span style=color:#a6e22e>delim</span>.<span style=color:#a6e22e>left</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;([\\S\\s]*?)&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>escapeRegex</span>(<span style=color:#a6e22e>delim</span>.<span style=color:#a6e22e>right</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;g&#34;</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>html</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>html</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#a6e22e>regex</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>match</span>, <span style=color:#a6e22e>g1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>katex</span>.<span style=color:#a6e22e>renderToString</span>(<span style=color:#a6e22e>decode</span>(<span style=color:#a6e22e>g1</span>), {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>displayMode</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>delim</span>.<span style=color:#a6e22e>display</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>output</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;html&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>strict</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>macros</span><span style=color:#f92672>:</span> {},
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以想象得到的是这种方法会有误判，比如代码里边如果有<code>$</code>的话就会出现渲染错误。实际运行的时候发现错误分为两种，一种是直接渲染成功了但是渲染的结果有问题，这种对我来说是可以接受的，因为在我常用的语言中似乎没有对<code>$</code>有什么特殊的青睐，出现的概率很低，可以用替换的方式规避；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>self</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>               <span style=color:#f92672>^</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ParseError</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>KaTeX</span> <span style=color:#a6e22e>parse</span> <span style=color:#a6e22e>error</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Expected</span> <span style=color:#e6db74>&#39;EOF&#39;</span>, <span style=color:#a6e22e>got</span> <span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#a6e22e>at</span> <span style=color:#a6e22e>position</span> <span style=color:#ae81ff>30</span><span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>…</span><span style=color:#a6e22e>n</span> <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;color:#̲a6e22e&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#a6e22e>right</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/…</span>
</span></span></code></pre></div><p>另一种是直接程序异常了，比如上面在渲染这篇文章的时候code block里边<code>$</code>，并且中间有一些颜色变量，就导致了Katex渲染失败，这种就要么disable掉Katex的throw error的功能，接受可能出现的排版错乱，要么像我对这篇文章的处理一样加入白名单不进行再渲染，或者用其他符号代替然后进行说明，总体来看失败的概率还是很低的，属于可以接受的范围。</p><p>有了这个渲染脚本，再加上简单的读写文件操作就可以完成渲染的工作了，唯一缺的就是一个nodejs的运行环境了，这个时候就需要在CI里边增加setup环境的流程。我使用的是Github Action，创建一个nodejs的环境非常的简单</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Setup nodejs enviroment</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/setup-node@v3</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>node-version</span>: <span style=color:#ae81ff>18</span>
</span></span></code></pre></div><p>有了nodejs环境，再增加一个调用脚本渲染的step就可以了，当然这个过程要放到Hugo产生静态网页之后。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Render Katex on Server Side</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          </span>          <span style=color:#ae81ff>node math.js &lt;posts&gt;</span>
</span></span></code></pre></div><p>当然，这个stpes可以选择再封装一层用来处理所有的posts，这里就不赘述了。</p><p>另外，我们实际上不再需要下载Katex的三个js文件了，可以将其从html里边删除掉，额外提升一点性能，参考代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>html</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>html</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>/&lt;script defer[\s\S]*?katex\@0\.16\.2[\s\S]*?&gt;[\s\S]*?&lt;\/script&gt;/gm</span>, <span style=color:#e6db74>&#34;&#34;</span>);
</span></span></code></pre></div><p>这就是我当前使用的渲染方式，使用这种方式前面的那篇长文章的加载速度从10s变到了5s左右，提升了50%的性能，效果还是不错的，而且对写作-发布的工作流也没有特别大的影响。</p><p><code>TODO:</code>未来如果正则匹配错误率太高的话可以选择parse html的方式，过滤掉code block再匹配替换。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://misha.brukman.net/blog/2022/04/writing-math-with-hugo/>Writing math with Hugo</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://graemephi.github.io/posts/static-katex-with-hugo/>Server-side KaTeX With Hugo</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://graemephi.github.io/posts/server-side-katex-with-hugo-part-2/>Server-side KaTeX With Hugo: Part 2</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div><script src=https://giscus.app/client.js data-repo=elinx/elinx.github.io data-repo-id=R_kgDOIPR9_w data-category=Announcements data-category-id=DIC_kwDOIPR9_84CSB4C data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=transparent_dark data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>&copy 2022 <a href=https://twitter.com/Elinx>Elinx</a> :: <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://elinx.github.io/assets/main.js></script>
<script src=https://elinx.github.io/assets/prism.js></script></div></body></html>