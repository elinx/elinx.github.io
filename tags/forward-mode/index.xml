<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Forward Mode on Collate, Summarize &amp; Explain</title><link>https://elinx.github.io/tags/forward-mode/</link><description>Recent content in Forward Mode on Collate, Summarize &amp; Explain</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy 2022 &lt;a href=https://twitter.com/Elinx>Elinx&lt;/a> :: &lt;a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0&lt;/a></copyright><lastBuildDate>Wed, 12 Oct 2022 22:28:01 +0800</lastBuildDate><atom:link href="https://elinx.github.io/tags/forward-mode/index.xml" rel="self" type="application/rss+xml"/><item><title>Deep Learning Matrix Calculus</title><link>https://elinx.github.io/posts/deep-learning-matrix-calculus/</link><pubDate>Wed, 12 Oct 2022 22:28:01 +0800</pubDate><guid>https://elinx.github.io/posts/deep-learning-matrix-calculus/</guid><description>预备知识 矩阵基本概念 在下面的公式推导中，我们都用小写字母表示标量，比如$x, y, z$，用小写的加箭头字母表示向量，比如$\vec{x}, \vec{y}, \v</description><content>&lt;h1 id="预备知识">预备知识&lt;/h1>
&lt;h2 id="矩阵基本概念">矩阵基本概念&lt;/h2>
&lt;p>在下面的公式推导中，我们都用小写字母表示标量，比如$x, y, z$，用小写的加箭头字母表示向量，比如$\vec{x}, \vec{y}, \vec{z}$，所有的公式中使用的向量都是列向量，比如长度为$\left|\vec{x}\right|=n$的向量为：
$$
\vec{x}=\begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n\end{bmatrix}
$$
行向量用其转置来表示，也就有：
$$
\vec{x}^\intercal=\begin{bmatrix} x_1 &amp;amp; x_2 &amp;amp; \dots &amp;amp; x_n\end{bmatrix}
$$&lt;/p>
&lt;h3 id="逐点乘积hadamard-product-element-wise-multiplication">逐点乘积(Hadamard Product, Element-wise Multiplication)&lt;/h3>
&lt;p>相同维度的向量或者矩阵每个元素的乘积，结果是一个向量，记为$\bm{w}\odot\bm{x}$，表示的运算为：&lt;/p>
&lt;p>$$
\vec{w}\odot\vec{x}=\begin{bmatrix} w_1x_1 \\ w_2x_2 \\ \vdots \\ w_nx_n\end{bmatrix}
$$&lt;/p>
&lt;h3 id="点积dot-product">点积(Dot Product)&lt;/h3>
&lt;p>我们用$\vec{w}\cdot\vec{x}$表示向量的点积，点积的结果是一个标量：
$$
\vec{w}\cdot\vec{x}=\sum_{i}^{n}{w_ix_i}=sum(\vec{w}\odot\vec{x})
$$&lt;/p>
&lt;h3 id="外积outer-product">外积(Outer Product)&lt;/h3>
&lt;p>我们用$\vec{u} \otimes \vec{v}$表示向量$|\vec{u}|=m$和向量$|\vec{v}|=n$的外积，外积的结果是一个$m \times n$的矩阵：
$$
\vec{u} \otimes \vec{v}=
\begin{bmatrix}
u_{1} v_{1} &amp;amp; u_{1} v_{2} &amp;amp; \cdots &amp;amp; u_{1} v_{n} \\
u_{2} v_{1} &amp;amp; u_{2} v_{2} &amp;amp; \cdots &amp;amp; u_{2} v_{n} \\
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
u_{n} v_{1} &amp;amp; u_{n} v_{2} &amp;amp; \cdots &amp;amp; u_{m} v_{n}
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="梯度gradient">梯度(Gradient)&lt;/h3>
&lt;p>梯度是多元变量函数中输出标量对于输入参数的导数，对于函数$f:\R^n \mapsto \R$，其对输入向量$\vec{x}$的梯度记为：
$$
\nabla f=
\begin{bmatrix}
\frac{\partial{f}}{\partial{x_1}} \\
\frac{\partial{f}}{\partial{x_2}} \\
\vdots \\
\frac{\partial{f}}{\partial{x_n}}
\end{bmatrix}
$$
梯度是一个向量，表示对输入的变化输出增长最快的方向，这句话怎么直观的理解呢？&lt;/p>
&lt;img src="./images/directional-derivative.png" class="center" style="max-width: 60%;" />
&lt;p>举个实际的例子，假设我们有函数$f=x^2+y^2$，有一个输入点$A(1, 1)$，我们怎样移动$A$才能使$f$的变化最大？我们假设只能移动距离为1，在二维空间我们可以以$A$为圆心随意移动，我们只用求$f$变化最大的值就可以了，我们可以三角函数表示移动后的点，假设为$B(A_x+cos(\theta), A_y+sin(\theta))$，带入$f$得到$f=&amp;hellip;+2(sin(\theta)+cos(\theta))$，我们知道只有$\theta=45^{\circ}$的时候值才是最大的，也就是我们如果让$A$沿着45度角的方向走的话$f$变化是最大的。 这种解法给了我们一个直观的解释，$A$按照某一个特定的方向向量走才能找到最大值，观察一下就可以发现它刚好是两个偏导数组成的方向$\overrightarrow{OA}(2, 2)$，但是不是所有的函数都可以这么解，如果函数比较复杂，或者维度比较高的时候就很难求解了，这个时候我们要用更微观的角度去看，也就是到了微分的领域，更具体的在多元变量函数里边我们用全微分来考察一下这两者的关系。&lt;/p>
&lt;p>全微分说的是我们有一个函数$f(x, y, z)$其结果的增量为所有自变量乘以偏导的和:
$$
df=\frac{\partial f}{\partial x}dx+\frac{\partial f}{\partial y}dy+\frac{\partial f}{\partial z}dz
$$&lt;/p>
&lt;p>这里每一项表示对一个微小的自变量变化，比如$dx$对结果的贡献是$x$的偏微分乘以$dx$，这里的操作实际上是固定了一个关于$x$的截面，在这个截面里边$x$和$f$是对应关系，$y$和$z$是常数，用导数乘以$x$的变化量就是$f$的变化量，这跟在一维空间里边用导数求结果增量的行为是一致的。 但是为什么最终的结果三项相加呢？这里使用的是一种线性近似的技术(Local Linear Approximation)&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，当变化量趋近于无穷小的时候等式成立：
$$
f\left(x,y\right)\approx f\left(a,b\right) + \frac{\partial f}{\partial x} \left(a,b\right)\left(x-a\right) + \frac{\partial f}{\partial y} \left(a,b\right)\left(y-b\right).
$$&lt;/p>
&lt;p>这个全微分我们可以看做是两个向量的点积，也就是
$$
df=
\begin{bmatrix}
\frac{\partial f}{\partial x} \\
\frac{\partial f}{\partial y} \\
\frac{\partial f}{\partial z}
\end{bmatrix} \cdot
\begin{bmatrix}
dx \\
dy \\
dz
\end{bmatrix} = \nabla f \cdot \vec{e}
$$&lt;/p>
&lt;p>当我们沿着任意一个方向向量$\vec{u}$走的时候其实可以将其可以看做是以$dx, dy, dz$为基底的线性组合，也就有了更一般的形式：
$$
df = \nabla f \vec{u}
$$&lt;/p>
&lt;p>我们知道当这两个向量的夹角为0的时候点积的结果最大，也就是$\nabla f$和$\vec{u}$是一个方向，我们就将前面用偏微分表示的的向量称作梯度，这也就说明了为什么梯度的方向是结果变化最快的方向:
$$
\nabla f=
\begin{bmatrix}
\frac{\partial f}{\partial x} \\
\frac{\partial f}{\partial y} \\
\frac{\partial f}{\partial z}
\end{bmatrix}
$$&lt;/p>
&lt;p>换句话说在$f$定义域内的一个点，如果这个点按照梯度的方向一直走，它就会一直走直到找到一个$f$的极大值点，相反如果它一直按照梯度的反方向走，那么它就会找到一个极小值点，这个时候各个自变量的偏导都可能是0了，也就不能再往下走了。更具体点有这么个函数$l=\vec{w}^\intercal\vec{x}$，其中$\vec{x}$是固定的，我们怎么调整$\vec{w}$才能让$l$变小呢？让$\vec{w}^\intercal$按照梯度的反方向就可以了，这也就是梯度下降的基本原理了。&lt;/p>
&lt;h3 id="雅各比矩阵jacobian">雅各比矩阵(Jacobian)&lt;/h3>
&lt;p>在上面其实我们用线性近似的方式解决了多元函数在局部空间的一维增量计算，但是实际上还有更一般的情况，也就是结果是一个向量，而不是一个标量：
$$
f: \R \mapsto \R \nlspc
f(\vec{x}): \R^n \mapsto \R \nlspc
\vec{f}(\vec{x}): \R^n \mapsto \R^m
$$
前两类的结构都是一个标量，最后一个结果是一个向量，我们怎么近似向量呢，怎么来衡量向量的接近程度呢？实际上现有的方法并不是综合考虑结果向量，而是让每一个向量的元素都接近来近似的，也就是说对于下面的映射$\R^2 \mapsto \R^3$
$$
\begin{bmatrix}
y_1 \\ y_2 \\ y_3
\end{bmatrix}=
\begin{bmatrix}
f_1(\vec{x}) \\
f_2(\vec{x}) \\
f_3(\vec{x})
\end{bmatrix}=
\begin{bmatrix}
f_1(x_1, x_2) \\
f_2(x_1, x_2) \\
f_3(x_1, x_2)
\end{bmatrix}
$$
我们可以用下面的方式，对于我们知道输入的一个点$(a, b)$的值，我们可以用导数乘以变化量的方式估算两个方向都有微小的变化$(x, y)$的值：
$$
f_1\left(x,y\right)\approx f_1\left(a,b\right) + \pdiff{f_1}{x}\left(a,b\right)\left(x-a\right) + \pdiff{f_1}{y} \left(a,b\right)\left(y-b\right) \nlspc
f_2\left(x,y\right)\approx f_2\left(a,b\right) + \pdiff{f_2}{x}\left(a,b\right)\left(x-a\right) + \pdiff{f_2}{y} \left(a,b\right)\left(y-b\right) \nlspc
f_3\left(x,y\right)\approx f_3\left(a,b\right) + \pdiff{f_3}{x}\left(a,b\right)\left(x-a\right) + \pdiff{f_3}{y} \left(a,b\right)\left(y-b\right)
$$
在考虑无穷小的时候也就有向量的全微分公式：
$$
\begin{bmatrix}
df_1=\pdiff{f_1}{x_1}dx_1+\pdiff{f_1}{x_2}dx_2 \nlspc
df_2=\pdiff{f_2}{x_1}dx_1+\pdiff{f_2}{x_2}dx_2 \nlspc
df_3=\pdiff{f_3}{x_1}dx_1+\pdiff{f_3}{x_2}dx_2
\end{bmatrix}
$$
整理一下可以表示成矩阵乘以一个向量的形式，表达的意思也更明确，一个向量在定义域内的微小变动对输出向量的影响可以用Jacobian表达出来，表达的基本思维是用了线性近似的方式：
$$
\begin{bmatrix} df_1 \nlspc df_2 \nlspc df_3 \nlspc \end{bmatrix}=
\begin{bmatrix}
\pdiff{f_1}{x_1}&amp;amp;\pdiff{f_1}{x_2} \nlspc
\pdiff{f_2}{x_1}&amp;amp;\pdiff{f_2}{x_2} \nlspc
\pdiff{f_3}{x_1}&amp;amp;\pdiff{f_3}{x_2} \nlspc
\end{bmatrix}
\begin{bmatrix} dx_1 \nlspc dx_2 \end{bmatrix}
$$
我们将矩阵的部分叫做Jacobian矩阵，可以看到&lt;code>Jacobian的表示方式跟Gradient并无二致，只是简单的将向量的单个分量分开表示&lt;/code>，那这种方式是不是有优化的空间呢？&lt;/p>
&lt;p>现在将其写作一般的形式有
$$
J_f(x)=\pdiff{\vec{y}}{\vec{x}}=
\begin{bmatrix}
\pdiff{f_1}{\vec{x}} \nlspc
\pdiff{f_2}{\vec{x}} \nlspc
\vdots \nlspc
\pdiff{f_m}{\vec{x}}
\end{bmatrix}=
\begin{bmatrix}
\pdiff{f_1}{x_1}&amp;amp; \pdiff{f_1}{x_2}&amp;amp; \ldots &amp;amp; \pdiff{f_1}{x_n} \nlspc
\pdiff{f_2}{x_1}&amp;amp; \pdiff{f_2}{x_2}&amp;amp; \ldots &amp;amp; \pdiff{f_2}{x_n} \nlspc
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \nlspc
\pdiff{f_m}{x_1}&amp;amp; \pdiff{f_m}{x_2}&amp;amp; \ldots &amp;amp; \pdiff{f_m}{x_n}
\end{bmatrix}= \nlspc
\begin{bmatrix}
\pdiff{\vec{f}}{x_1}&amp;amp; \pdiff{\vec{f}}{x_2}&amp;amp; \ldots &amp;amp; \pdiff{\vec{f}}{x_n}
\end{bmatrix}=
\begin{bmatrix}
\nabla{f_1}(\vec{x})^\intercal \nlspc
\nabla{f_2}(\vec{x})^\intercal \nlspc
\vdots \nlspc
\nabla{f_m}(\vec{x})^\intercal
\end{bmatrix}
$$&lt;/p>
&lt;blockquote>
&lt;p>注意最后一步是因为梯度是按列排布的，转置之后才会放到行上面，所以是每一个函数的梯度的转置而不是整体函数的转置。&lt;/p>
&lt;/blockquote>
&lt;h4 id="jvpjacobian-vector-product">JVP(Jacobian Vector Product)&lt;/h4>
&lt;p>将Jacobian右乘一个向量$\vec{v}\in\R^n$我们就得到了&lt;code>JVP&lt;/code>形式，注意最后的矩阵里边是点乘，最后的结果是一个$(M, 1)$的向量：&lt;/p>
&lt;p>$$
J_f(x)\vec{v} =
\begin{bmatrix}
\nabla{f_1}(\vec{x})^\intercal \nlspc
\nabla{f_2}(\vec{x})^\intercal \nlspc
\vdots \nlspc
\nabla{f_m}(\vec{x})^\intercal
\end{bmatrix} \vec{v}=
\begin{bmatrix}
\nabla{f_1}(\vec{x})\cdot\vec{v} \nlspc
\nabla{f_2}(\vec{x})\cdot\vec{v} \nlspc
\vdots \nlspc
\nabla{f_m}(\vec{x})\cdot\vec{v}
\end{bmatrix}
$$&lt;/p>
&lt;p>假如这里的向量是一个one-hot的单位向量的话JVP可以求出原来Jacobian的某一列，比如$\vec{v}=\vec{e_1}=[0, 1, 0, \dots, 0]^\intercal$只有第二个元素是1其他都是0，那么得到的结果是所有函数对$x_1$变量的偏导
$$
J_f(x)\vec{v} = J_f(x)\vec{e_1}=
\begin{bmatrix}
\nabla{f_1}(\vec{x})\cdot\vec{e_1} \nlspc
\nabla{f_2}(\vec{x})\cdot\vec{e_1} \nlspc
\vdots \nlspc
\nabla{f_m}(\vec{x})\cdot\vec{e_1}
\end{bmatrix}=
\begin{bmatrix}
\pdiff{f_1}{\vec{x_2}} \nlspc
\pdiff{f_2}{\vec{x_2}} \nlspc
\vdots \nlspc
\pdiff{f_m}{\vec{x_2}}
\end{bmatrix}
$$&lt;/p>
&lt;h4 id="vjpvector-jacobian-product">VJP(Vector Jacobian Product)&lt;/h4>
&lt;p>而将Jacobian左乘一个向量$\vec{u}\in\R^m$我们就得到了&lt;code>VJP&lt;/code>形式，注意左边的向量$\vec{u}$是1行m列的，用了转置表示行向量，最后的矩阵里边也是点乘，所以它是一个$(1, N)$的向量：&lt;/p>
&lt;p>$$
\vec{u}^\intercal J_f(x) = \vec{u}^\intercal
\begin{bmatrix}
\pdiff{\vec{f}}{x_1}&amp;amp; \pdiff{\vec{f}}{x_2}&amp;amp; \ldots &amp;amp; \pdiff{\vec{f}}{x_n}
\end{bmatrix}=
\begin{bmatrix}
\vec{u}^\intercal\cdot\pdiff{\vec{f}}{x_1}&amp;amp; \vec{u}^\intercal\cdot\pdiff{\vec{f}}{x_2}&amp;amp; \ldots &amp;amp; \vec{u}^\intercal\cdot\pdiff{\vec{f}}{x_n}
\end{bmatrix}
$$&lt;/p>
&lt;p>同样的如果假如这里的向量是一个one-hot的单位向量的话VJP可以求出原来Jacobian的某一行，比如$\vec{u}=\vec{e_1}=[0, 1, 0, \dots, 0]$只有第二个元素是1其他都是0，那么得到的结果是一个函数对所有变量的偏导，也就是$f_2$函数的梯度
$$
\vec{u}^\intercal J_f(x) = \vec{e_1}^\intercal J_f(x) =
\begin{bmatrix}
\pdiff{\vec{f_2}}{x_1}&amp;amp; \pdiff{\vec{f_2}}{x_2}&amp;amp; \ldots &amp;amp; \pdiff{\vec{f_2}}{x_n}
\end{bmatrix} = \nabla f_2(\vec{x})
$$&lt;/p>
&lt;h3 id="矩阵的乘法matrix-multiplication">矩阵的乘法(Matrix Multiplication)&lt;/h3>
&lt;h3 id="矩阵的点乘matrix-dot-production">矩阵的点乘(Matrix Dot Production)&lt;/h3>
&lt;h3 id="权重的矩阵表示">权重的矩阵表示&lt;/h3>
&lt;p>每个神经元的权重是一个列向量，多个神经元向量组成矩阵，我们遵守常用记号，将其作为神经元的行向量&lt;/p>
&lt;p>Tensorflow和Pytorch中的Input矩阵在表示的时候都是将features放到了行上面，多个feature按照多行排布，比如下面表示特征向量有n个元素，有m个向量的$\bm{X}$其形状为$(M, N)$
$$
\bm{X} = \begin{bmatrix} \vec{x_1} \\ \vec{x_2} \\ \vdots \\ \vec{x_m}\end{bmatrix} = \begin{vmatrix}
x_{11} &amp;amp; x_{12} &amp;amp; \dots &amp;amp; x_{1n} \\
x_{21} &amp;amp; x_{22} &amp;amp; \dots &amp;amp; x_{2n} \\
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \vdots \\
x_{m1} &amp;amp; x_{m2} &amp;amp; \dots &amp;amp; x_{mn} \\
\end{vmatrix}
$$
对权重的放置却略有不同，Tensorflow会将权重向量放到列上，而Pytorch会放到行上，也就是对应于上面的输入向量，有K个神经元，每个神经元是N个特征的话，Tensorflow的表示的形状是$(N, K)$，也就是K个N维的列向量：
$$
\bm{W} = \begin{bmatrix} \vec{w_1}, \vec{w_2},\dots, \vec{w_k}\end{bmatrix} = \begin{vmatrix}
w_{11} &amp;amp; w_{21} &amp;amp; \dots &amp;amp; w_{k1} \\
w_{12} &amp;amp; w_{22} &amp;amp; \dots &amp;amp; w_{k2} \\
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \vdots \\
w_{1n} &amp;amp; w_{2n} &amp;amp; \dots &amp;amp; w_{kn} \\
\end{vmatrix}
$$
Pytorch的形状却是$(K, N)$，也就是K个N维的行向量：
$$
\bm{W} = \begin{bmatrix} \vec{w_1} \\ \vec{w_2} \\ \vdots \\ \vec{w_k}\end{bmatrix} = \begin{vmatrix}
w_{11} &amp;amp; w_{12} &amp;amp; \dots &amp;amp; w_{1n} \\
w_{21} &amp;amp; w_{22} &amp;amp; \dots &amp;amp; w_{2n} \\
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \vdots \\
w_{k1} &amp;amp; w_{k2} &amp;amp; \dots &amp;amp; w_{kn} \\
\end{vmatrix}
$$
因此其&lt;code>Dense/Linear&lt;/code>的做法也不相同，Tensorflow是$\bm{Y}=\bm{X}\bm{W}$，Pytorch的是$\bm{Y}=\bm{X}\bm{W^\intercal}$，得到的结果都是一样的，也就是batch是行，特征是列，有多少行就有多少个batch。&lt;/p>
&lt;h2 id="tensor基本概念">Tensor基本概念&lt;/h2>
&lt;h3 id="axis-and-shape">Axis and Shape&lt;/h3>
&lt;p>对于Tensor $\bm{X}_{i, j, k}$，它的维度也就是轴是从高到低排序的，这也就意味着在2D里边行是0轴，列是1轴，而到了3D里边，channel是0轴，行是1轴，列是2轴，这在reduction操作里边就意味着指定的是哪一个维度，哪一维度就会消失。&lt;/p>
&lt;img src="./images/axis-stride.png" class="center" style="max-width: 80%;" />
&lt;img src="./images/3d-axis-stride.png" class="center" style="max-width: 80%;" />
&lt;h3 id="stride">Stride&lt;/h3>
&lt;p>Tensor的shape和size是用户关心的，而storage和stride是底层实现者需要关注的，一般来说Tensor的底层实现都是1D的，用stride可以将用户的索引变的更简单。&lt;/p>
&lt;p>比如一个Tensor $\bm{X}_{4 \times 2}$，如果是先按行再按列的方式存储，其形状为
$$
\begin{array}{|c|c|}
\hline x_1 &amp;amp; x_2 \\
\hline x_3 &amp;amp; x_4 \\
\hline \empsym{x_5} &amp;amp; \empsym{x_6} \\
\hline x_7 &amp;amp; x_8 \\
\hline
\end{array}
$$
对应的底层storage如下所示，这种存储是连续的，它的strides就是&lt;code>(2, 1)&lt;/code>，表示在列上移动单位是1，在行上的移动单位是2。
$$
storage:
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline x_1 &amp;amp; x_2 &amp;amp; x_3 &amp;amp; x_4 &amp;amp; \empsym{x_5} &amp;amp; \empsym{x_6} &amp;amp; x_7 &amp;amp; x_8 \\ \hline
\end{array}
$$
假设现在我们要对$\bm{X}$做transpose，行列形状发生变化之后是$\bm{X}_{2\times 4}$，如果没有stride我们就需要变换底层的storage，但是实际上我们不用变底层的storage，只需要将stride调换即可，变成&lt;code>(1, 2)&lt;/code>，这样访问的时候列上走两格访问一个元素，换行只需要加一个元素，就可以得到想要的访问顺序。&lt;/p>
&lt;p>$$
\begin{array}{|c|c|c|c|}
\hline x_1 &amp;amp; x_3 &amp;amp; \empsym{x_5} &amp;amp; x_7 \\
\hline x_2 &amp;amp; x_4 &amp;amp; \empsym{x_6} &amp;amp; x_8 \\
\hline
\end{array}
$$
$$
storage:
\begin{array}{|c|c|c|c|c|c|c|c|}
\hline x_1 &amp;amp; x_2 &amp;amp; x_3 &amp;amp; x_4 &amp;amp; \empsym{x_5} &amp;amp; \empsym{x_6} &amp;amp; x_7 &amp;amp; x_8 \\ \hline
\end{array}
$$
如果访问的元素坐标是&lt;code>tensor[i, j]&lt;/code>，并且strides是$(s_1, s_2)$，那么从storage拿元素的公式就是
$$
storage[s_1 * i + s_2 * j]
$$&lt;/p>
&lt;p>更一般的，我们将其扩展到任意维的tensor的话就有：
$$
\bm{X}_{\overrightarrow{index}} = storage[\sum^{|\overrightarrow{index}|}_i \vec{s}_i*\overrightarrow{index}_i]
$$&lt;/p>
&lt;h3 id="broadcasting">Broadcasting&lt;/h3>
&lt;p>广播是一种匹配不同形状数组的维度的操作，以便能够对这些数组执行进一步的操作，广播其实类似于类型提升，主要方便写代码的。&lt;/p>
&lt;blockquote>
&lt;p>Broadcasting is akin to the well known “type promotion”: in most languages when adding an integer and a float, the integer is auto converted to the float type first.&lt;/p>
&lt;/blockquote>
&lt;p>比如一个有趣的例子，如果让两个向量$\vec{u}_{1,3}$和向量$\vec{v}_{3,1}$点乘的话得到的却是一个外积：&lt;/p>
&lt;p>$$
\begin{array}{|c|c|c|}
\hline \empsym{1} &amp;amp; \empsym{2} &amp;amp; \empsym{3} \\
\hdashline 1&amp;amp;2&amp;amp;3 \\
\hdashline 1&amp;amp;2&amp;amp;3 \\
\hdashline
\end{array} *
\begin{array}{|c:c:c:}
\hline \empsym{1}&amp;amp;1&amp;amp;1 \\
\hline \empsym{2}&amp;amp;2&amp;amp;2 \\
\hline \empsym{3}&amp;amp;3&amp;amp;3 \\
\hline
\end{array} =
\begin{array}{|c|c|c|}
\hline 1&amp;amp;2&amp;amp;3 \\
\hline 2&amp;amp;4&amp;amp;6 \\
\hline 3&amp;amp;6&amp;amp;9 \\
\hline
\end{array}
$$&lt;/p>
&lt;p>高纬的操作很不直观，但是记住这三条rules就会容易理解了&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>:&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Rule 1&lt;/strong>: If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.&lt;br>
&lt;strong>Rule 2&lt;/strong>: If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.&lt;br>
&lt;strong>Rule 3&lt;/strong>: If in any dimension the sizes disagree and neither is equal to 1, an error is raised.&lt;/p>
&lt;/blockquote>
&lt;p>算法参考实现如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">shape_broadcast&lt;/span>(shape1, shape2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dims &lt;span style="color:#f92672">=&lt;/span> max(len(shape1), len(shape2))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out &lt;span style="color:#f92672">=&lt;/span> ()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shape1 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>,) &lt;span style="color:#f92672">*&lt;/span> abs(dims &lt;span style="color:#f92672">-&lt;/span> len(shape1)) &lt;span style="color:#f92672">+&lt;/span> shape1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shape2 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>,) &lt;span style="color:#f92672">*&lt;/span> abs(dims &lt;span style="color:#f92672">-&lt;/span> len(shape2)) &lt;span style="color:#f92672">+&lt;/span> shape2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> s1, s2 &lt;span style="color:#f92672">in&lt;/span> zip(shape1, shape2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> s1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> o &lt;span style="color:#f92672">=&lt;/span> s2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> s2 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> o &lt;span style="color:#f92672">=&lt;/span> s1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> s1 &lt;span style="color:#f92672">==&lt;/span> s2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> o &lt;span style="color:#f92672">=&lt;/span> s1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> s1 &lt;span style="color:#f92672">!=&lt;/span> s2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">raise&lt;/span> IndexingError(s1, s2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out &lt;span style="color:#f92672">+=&lt;/span> (o,)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>t &lt;span style="color:#f92672">=&lt;/span> minitorch&lt;span style="color:#f92672">.&lt;/span>shape_broadcast((&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>), (&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">assert&lt;/span> minitorch&lt;span style="color:#f92672">.&lt;/span>shape_broadcast(t, (&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">==&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="indexing-and-slicing">Indexing and Slicing&lt;/h3>
&lt;p>这里主要关注的点是Slicing会创建一个view，这个view复用了原来的storage，只是shape和stride发生了变化。例如一个矩阵$\bm{B}_{3,4}$，strides是&lt;code>(4, 1)&lt;/code>，然后对其切片&lt;code>B[1:3,1:3]&lt;/code>，其底层的storage不变，stride仍然是&lt;code>(4, 1)&lt;/code>，但是后者的起始位置发生了变化，可以表示如下&lt;/p>
&lt;img src="./images/view-axis-stride.png" class="center" style="max-width: 80%;" />
&lt;h3 id="contiguity">Contiguity&lt;/h3>
&lt;p>我们知道Tensor的layout有两种，一种是Row Major(C order)，一种是Column Major(Fortran Order)，但是在大多数的计算库中两种都支持，为什么可以支持两种表示，支持两种有什么好处，额外的负担是什么呢？&lt;/p>
&lt;p>用C order的话越低的维度的stride就越大，而Fortan则相反。判断连续性的方法是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The traditional rule is that for an array to be flagged as C contiguous,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * the following must hold:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * strides[-1] == itemsize
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * strides[i] == shape[i+1] * strides[i + 1]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * And for an array to be flagged as F contiguous, the obvious reversal:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * strides[0] == itemsize
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * strides[i] == shape[i - 1] * strides[i - 1]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了连续性标志有两方面的好处，如果是C order的话，对于连续性的内存可以连续性的遍历每一个元素，不用跳跃，因此可以用向量化等优化计算；另一个好处是如果是reshape操作的话，可以不用copy到另一个数组，也就是&lt;code>reval&lt;/code>操作的作用&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。&lt;/p>
&lt;h1 id="求导">求导&lt;/h1>
&lt;h2 id="链式法则chain-rule">链式法则(Chain Rule)&lt;/h2>
&lt;p>级联函数或者组合函数求导为什么要用乘法呢？为什么不是加法或者除法呢？有这样一个例子，汽车在从山脚到山顶开，高度每小时升高1km，而山上的温度是每上升1km下降5$^\circ C$，那最终汽车开了两个小时温度上升多少度呢？显然要用乘法$2 \times 5$也就是10度，虽然这里时间很长，但是当我们看一个微小的变化量的时候，这个结果依然成立，这就可以给复合函数变化率为什么要用乘法提供一个直观的理解。&lt;/p>
&lt;p>那分叉的函数为什么要用加法呢？比如下面的两个分支，最后的结果的操作&lt;code>op&lt;/code>无论是什么，求导的时候都是将几部分相加。
$$
y_1 = exp(x) \nlspc
y_2 = tanh(x) \nlspc
y = y_1 \circ y_2
$$&lt;/p>
&lt;p>这是因为我们计算微分的时候用的线性近似，即便最后的&lt;code>op&lt;/code>是一个$y^z$这样的形式，其增量仍然是两个变量的全微分形式也即两部分引起的增量的加和，这也就解释了为什么总是有一个加法，因为&lt;code>线性近似总是两个分量引起的最终变化量的线性加法和&lt;/code>，注意下面的加号：&lt;/p>
&lt;p>$$
\delta = f\left(x,y\right) - f\left(a,b\right) \approx \frac{\partial f}{\partial x} \left(a,b\right)\left(x-a\right) \empsym{+} \frac{\partial f}{\partial y} \left(a,b\right)\left(y-b\right)
$$&lt;/p>
&lt;p>在实现的时候呢，我们要先建立一个DAG，然后拓扑排序之后才能实现累计的效果。&lt;/p>
&lt;center>&lt;div class="mermaid">graph LR;
A((x))
B((exp))
C((tanh))
D((op))
A-->B;
A-->C;
B-->D;
C-->D;&lt;/div>&lt;/center>
&lt;h2 id="标量对向量求导">标量对向量求导&lt;/h2>
&lt;p>对于函数$f(\vec{x})=y$, $y$对输入$\vec{x}$的导数我们统一按照Jacobian的方式存放，也就是：
$$
\frac{dy}{d\vec{x}}=
\begin{bmatrix}
\frac{df}{dx_1} &amp;amp; \frac{df}{dx_2} &amp;amp; \dots &amp;amp; \frac{df}{dx_n}
\end{bmatrix}
$$&lt;/p>
&lt;h2 id="向量对向量求导">向量对向量求导&lt;/h2>
&lt;p>不同于上面的$y$是一个标量，这里的$\vec{y}$是一个m维的向量，对应的表达式是$\vec{y}=\vec{f}(\vec{x})$展开之后是：
$$
\begin{bmatrix}
y_1 \\ y_2 \\ \vdots \\ y_m
\end{bmatrix}=
\begin{bmatrix}
f_1(\vec{x}) \\
f_2(\vec{x}) \\
\vdots \\
f_m(\vec{x}) \\
\end{bmatrix}=
\begin{bmatrix}
f_1(x_1, x_2, &amp;hellip;, x_n) \\
f_2(x_1, x_2, &amp;hellip;, x_n) \\
\vdots \\
f_n(x_1, x_2, &amp;hellip;, x_n) \\
\end{bmatrix}
$$&lt;/p>
&lt;p>而$\vec{y}$对$\vec{x}$的导数也就成了对$\vec{x}$各个分量的偏导数，也就是Jacobian矩阵：&lt;/p>
&lt;p>$$
\pdiff{\vec{y}}{\vec{x}}=
\begin{bmatrix}
\pdiff{f_1}{\vec{x}} \nlspc
\pdiff{f_2}{\vec{x}} \nlspc
\vdots \nlspc
\pdiff{f_m}{\vec{x}}
\end{bmatrix}=
\begin{bmatrix}
\pdiff{f_1}{x_1}&amp;amp;
\pdiff{f_1}{x_2}&amp;amp;
\ldots &amp;amp;
\pdiff{f_1}{x_n} \nlspc
\pdiff{f_2}{x_1}&amp;amp;
\pdiff{f_2}{x_2}&amp;amp;
\ldots &amp;amp;
\pdiff{f_2}{x_n} \nlspc
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \nlspc
\pdiff{f_m}{x_1}&amp;amp;
\pdiff{f_m}{x_2}&amp;amp;
\ldots &amp;amp;
\pdiff{f_m}{x_n}
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="逐元素element-wise操作的求导">逐元素(Element-wise)操作的求导&lt;/h3>
&lt;p>这种比较常出现在激活函数，也就是对输入向量的每个元素求值，更泛化的形式是两个矩阵逐个进行binary操作，我们将其记为$\vec{y}=\vec{f}(\vec{w})\odot\vec{g}(\vec{x})$，这里的$\vec{y}, \vec{f}, \vec{g}, \vec{w},\vec{x}$都是向量并且其长度都是n，也就有：
$$
\begin{bmatrix}
y_1 \\ y_2 \\ \vdots \\ y_n
\end{bmatrix}=
\begin{bmatrix}
f_1(\vec{w}) \odot g_1(\vec{x}) \\
f_2(\vec{w}) \odot g_2(\vec{x}) \\
\vdots \\
f_n(\vec{w}) \odot g_n(\vec{x}) \\
\end{bmatrix}=
\begin{bmatrix}
f_1(w_1, w_2, &amp;hellip;, w_n) \odot g_1(x_1, x_2, &amp;hellip;, x_n) \\
f_2(w_1, w_2, &amp;hellip;, w_n) \odot g_2(x_1, x_2, &amp;hellip;, x_n) \\
\vdots \\
f_n(w_1, w_2, &amp;hellip;, w_n) \odot g_n(x_1, x_2, &amp;hellip;, x_n) \\
\end{bmatrix}
$$
套用上面Jacobian的一般形式我们得到：
$$
\pdiff{\vec{y}}{\vec{x}}=
\begin{bmatrix}
\pdiff{(f_1\odot g_1)}{\vec{x}} \nlspc
\pdiff{(f_2\odot g_2)}{\vec{x}} \nlspc
\vdots \nlspc
\pdiff{(f_n\odot g_n)}{\vec{x}}
\end{bmatrix}=
\begin{bmatrix}
\pdiff{(f_1\odot g_1)}{x_1}&amp;amp;
\pdiff{(f_1\odot g_1)}{x_2}&amp;amp;
\ldots &amp;amp;
\pdiff{(f_1\odot g_1)}{x_n} \nlspc
\pdiff{(f_2\odot g_2)}{x_1}&amp;amp;
\pdiff{(f_2\odot g_2)}{x_2}&amp;amp;
\ldots &amp;amp;
\pdiff{(f_2\odot g_2)}{x_n} \nlspc
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \nlspc
\pdiff{(f_n\odot g_n)}{x_1}&amp;amp;
\pdiff{(f_n\odot g_n)}{x_2}&amp;amp;
\ldots &amp;amp;
\pdiff{(f_n\odot g_n)}{x_n}
\end{bmatrix}
$$&lt;/p>
&lt;p>在深度学习中我们的操作如果是参数乘以输入的话呢，$\vec{f}, \vec{g}$就都是相当于一个选择函数，即$f_i(\vec{w})=w_i$和$g_i(\vec{x})=x_i$，这样面的矩阵就会变成一个对角阵
$$
\begin{bmatrix}
y_1 \\ y_2 \\ \vdots \\ y_n
\end{bmatrix}=
\begin{bmatrix}
f_1(\vec{w}) \odot g_1(\vec{x}) \\
f_2(\vec{w}) \odot g_2(\vec{x}) \\
\vdots \\
f_n(\vec{w}) \odot g_n(\vec{x}) \\
\end{bmatrix}=
\begin{bmatrix}
w_1 \odot x_1 \\
w_2 \odot x_2 \\
\vdots \\
w_n \odot x_n \\
\end{bmatrix}
$$
也就是说$y_1$只跟$x_1$有关，$y_2$只跟$x_2$有关，$y_n$只跟$x_n$有关，其他位置的元素都无关，也就是：
$$
\pdiff{\vec{y}}{\vec{x}}=
\begin{bmatrix}
\pdiff{(w_1\odot x_1)}{\vec{x}}\nlspc
\pdiff{(w_2\odot x_2)}{\vec{x}}\nlspc
\vdots\nlspc
\pdiff{(w_n\odot x_n)}{\vec{x}}
\end{bmatrix}=
\begin{bmatrix}
\pdiff{(w_1\odot x_1)}{x_1}&amp;amp; 0&amp;amp; \ldots &amp;amp; 0\nlspc
0&amp;amp; \pdiff{(w_2\odot x_2)}{x_2}&amp;amp; \ldots &amp;amp; 0\nlspc
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \nlspc
0&amp;amp; 0&amp;amp; \ldots &amp;amp; \pdiff{(w_n\odot x_n)}{x_n}
\end{bmatrix}=
\begin{bmatrix}
w_1&amp;amp;0&amp;amp;\ldots&amp;amp;0 \\
0&amp;amp;w_2&amp;amp;\ldots&amp;amp;0 \\
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\
0&amp;amp;0&amp;amp;\ldots&amp;amp;w_n \\
\end{bmatrix}
$$
如果这里是乘法的话就变成了参数的对角矩阵，同样的对参数的导数是关于输入向量的导数。我们用代码来验证一下结果是否正确，我们调用Pytorch的&lt;code>jacobian&lt;/code>来计算一下，首先我们需要引入一些必要的基础库，后面我们不再列出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> torch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> torch.autograd.functional &lt;span style="color:#f92672">import&lt;/span> jacobian
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> torch &lt;span style="color:#f92672">import&lt;/span> tensor
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们计算一个element-wise的矩阵乘法并分别对两个向量求导，可以看到结果跟我们上面的公式一致。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">1.&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>w &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">4.&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y &lt;span style="color:#f92672">=&lt;/span> w &lt;span style="color:#f92672">*&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dx &lt;span style="color:#f92672">=&lt;/span> jacobian(&lt;span style="color:#66d9ef">lambda&lt;/span> x: w &lt;span style="color:#f92672">*&lt;/span> x, x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dw &lt;span style="color:#f92672">=&lt;/span> jacobian(&lt;span style="color:#66d9ef">lambda&lt;/span> w: w &lt;span style="color:#f92672">*&lt;/span> x, w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;y: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>y&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">,&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">dy/dx: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>dx&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">,&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">dy/dw: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>dw&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># output&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># y: tensor([ 4., 10., 18.]),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># dy/dx: tensor([[4., 0., 0.],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [0., 5., 0.],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [0., 0., 6.]]),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># dy/dw: tensor([[1., 0., 0.],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [0., 2., 0.],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [0., 0., 3.]]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="点积dot-product的求导">点积(dot product)的求导&lt;/h3>
&lt;p>向量的点积表示为$y=\vec{w}\cdot\vec{x}$，也可以表示为$\vec{w}^\intercal\vec{x}$，同时还可以看作是element-wise向量乘操作之后再执行一个加和操作，也就是$\sum_i^n{w_ix_i}=sum(\vec{w}\odot\vec{x})$，借用这个转换我们可以利用链式法则求出向量点积的导数&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>我们先定义一个中间变量$\vec{u}$将表达式重写
$$
\vec{u}=\vec{w}\odot\vec{x} \\
y=sum(\vec{u})
$$
然后求各个中间变量对于$\vec{w}$的导数
$$
\frac{\partial{u}}{\partial{w}}=diag(\vec{x})=
\begin{bmatrix}
x_1&amp;amp;0&amp;amp;\dots&amp;amp;0\\
0&amp;amp;x_2&amp;amp;\dots&amp;amp;0\\
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\
0&amp;amp;0&amp;amp;\dots&amp;amp;x_n
\end{bmatrix} \\
\frac{\partial{y}}{\partial{u}}=\vec{1}^\intercal = [1_1, 1_2, &amp;hellip;, 1_n]
$$&lt;/p>
&lt;p>两个中间结果的乘积就是对$\vec{w}$的导数&lt;/p>
&lt;p>$$
\frac{\partial{y}}{\partial{\vec{w}}}=
\frac{\partial{y}}{\partial{\vec{u}}}\frac{\partial{\vec{u}}}{\partial{\vec{w}}}=
\vec{1}^\intercal diag(\vec{x})=[x_1, x_2, \dots, x_n]=\vec{x}^\intercal
$$&lt;/p>
&lt;p>同样的如果我们得到对$\vec{x}$的导数
$$
\frac{\partial{y}}{\partial{\vec{x}}}=\vec{w^\intercal}
$$&lt;/p>
&lt;p>另一种证明方法，我们先把$y$展开
$$
y = w_1x_1 + w_2x_2 + \dots + w_nx_n
$$
对其中的任意一个$w_i$求导，我们得到
$$
\frac{\partial y}{\partial w_i} = x_i
$$
也就有：
$$
\pdiff{y}{\vec{w}}=[x_1, x_2, \dots, x_n]=\vec{x}^\intercal
$$
具体的存放形式由实际实现来定。用代码验证一下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">1.&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>w &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">4.&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>dot(w, x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dx &lt;span style="color:#f92672">=&lt;/span> jacobian(&lt;span style="color:#66d9ef">lambda&lt;/span> x: torch&lt;span style="color:#f92672">.&lt;/span>dot(w, x), x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dw &lt;span style="color:#f92672">=&lt;/span> jacobian(&lt;span style="color:#66d9ef">lambda&lt;/span> w: torch&lt;span style="color:#f92672">.&lt;/span>dot(w, x), w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;y: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>y&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">,&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">dy/dx: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>dx&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">,&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">dy/dw: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>dw&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># y: 32.0,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># dy/dx: tensor([4., 5., 6.]),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># dy/dw: tensor([1., 2., 3.])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到&lt;code>torch.dot&lt;/code>的计算结果跟我们算出来的是一样的，而且这里Pytorch选择了放到行向量里边。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> tensor([[&lt;span style="color:#ae81ff">1.&lt;/span>], [&lt;span style="color:#ae81ff">2.&lt;/span>], [&lt;span style="color:#ae81ff">3.&lt;/span>]])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>w &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">4.&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>matmul(w, x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dx &lt;span style="color:#f92672">=&lt;/span> jacobian(&lt;span style="color:#66d9ef">lambda&lt;/span> x: torch&lt;span style="color:#f92672">.&lt;/span>matmul(w, x), x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dw &lt;span style="color:#f92672">=&lt;/span> jacobian(&lt;span style="color:#66d9ef">lambda&lt;/span> w: torch&lt;span style="color:#f92672">.&lt;/span>matmul(w, x), w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;y: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>y&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">,&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">dy/dx: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>dx&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">,&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">dy/dw: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>dw&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(dx&lt;span style="color:#f92672">.&lt;/span>shape, dw&lt;span style="color:#f92672">.&lt;/span>shape)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># y: tensor([32.]),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># dy/dx: tensor([[[4.],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [5.],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [6.]]]),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># dy/dw: tensor([[1., 2., 3.]])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># torch.Size([1, 3, 1]) torch.Size([1, 3])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是看&lt;code>torch.matmul&lt;/code>就跟我们求出来的基本一致，但是这里&lt;code>y&lt;/code>是一个1x1矩阵，&lt;code>dx&lt;/code>的形状也多了一维，但是仍然可以进行减法计算，而&lt;code>dw&lt;/code>的形状是对的。&lt;/p>
&lt;p>&lt;code>torch.matmul&lt;/code>还有一个性质就是如果输入都是一维向量的话结果是求两个的点积，也就是跟点积完全一样了，所以应该&lt;code>torch.dot&lt;/code>底层也是用&lt;code>torch.matmul&lt;/code>实现的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">1.&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>w &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">4.&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>matmul(w, x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dx &lt;span style="color:#f92672">=&lt;/span> jacobian(&lt;span style="color:#66d9ef">lambda&lt;/span> x: torch&lt;span style="color:#f92672">.&lt;/span>matmul(w, x), x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dw &lt;span style="color:#f92672">=&lt;/span> jacobian(&lt;span style="color:#66d9ef">lambda&lt;/span> w: torch&lt;span style="color:#f92672">.&lt;/span>matmul(w, x), w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;y: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>y&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">,&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">dy/dx: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>dx&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">,&lt;/span>&lt;span style="color:#ae81ff">\n\n&lt;/span>&lt;span style="color:#e6db74">dy/dw: &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>dw&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># y: 32.0,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># dy/dx: tensor([4., 5., 6.]),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># dy/dw: tensor([1., 2., 3.])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="矩阵乘向量对向量求导">矩阵乘向量对向量求导&lt;/h3>
&lt;p>多个神经元与对应一个输入向量的矩阵乘情形就是一个典型的矩阵乘向量的例子，我们表示为$\vec{y}=\bm{W}\vec{x}$，我们要求的导数是$\frac{\partial{\vec{y}}}{\partial{\vec{x}}}$，其中$\vec{x}$的是$N$维的向量，$\vec{y}$是$M$维的向量，而矩阵$\bm{W}$的形状是$(M, N)$，我们先将计算过程写成展开模式方便理解
$$
\begin{bmatrix}
y_1 \\ y_2 \\ \vdots \\ y_m
\end{bmatrix}=
\begin{bmatrix}
f_1(\vec{x}) \\
f_2(\vec{x}) \\
\vdots \\
f_m(\vec{x}) \\
\end{bmatrix}=
\begin{bmatrix}
f_1(x_1, x_2, &amp;hellip;, x_n) \\
f_2(x_1, x_2, &amp;hellip;, x_n) \\
\vdots \\
f_n(x_1, x_2, &amp;hellip;, x_n) \\
\end{bmatrix}=\nlspc
\begin{bmatrix}
W_{11}x_1+W_{12}x_2+\dots+W_{1n}x_n \\
W_{21}x_1+W_{22}x_2+\dots+W_{2n}x_n \\
\vdots \\
W_{m1}x_1+W_{m2}x_2+\dots+W_{mn}x_n \\
\end{bmatrix}=\nlspc
\begin{bmatrix}
\sum\limits_{i=1}^{N}{W_{1i}x_i}\\
\sum\limits_{i=1}^{N}{W_{2i}x_i}\\
\vdots \\
\sum\limits_{i=1}^{N}{W_{mi}x_i}\\
\end{bmatrix}
$$
因为输入输出都是向量，我们就能够得到Jacobian的形式：
$$
\frac{\partial{\vec{y}}}{\partial{\vec{x}}}=
\begin{bmatrix}
\frac{\partial{\sum\limits_{i=1}^{N}{W_{1i}x_i}}}{\partial{x_1}}&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{W_{1i}x_i}}}{\partial{x_2}}&amp;amp;
\dots&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{W_{1i}x_i}}}{\partial{x_n}}&amp;amp;\nlspc
\frac{\partial{\sum\limits_{i=1}^{N}{W_{2i}x_i}}}{\partial{x_1}}&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{W_{2i}x_i}}}{\partial{x_2}}&amp;amp;
\dots&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{W_{2i}x_i}}}{\partial{x_n}}&amp;amp;\nlspc
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots \nlspc
\frac{\partial{\sum\limits_{i=1}^{N}{W_{mi}x_i}}}{\partial{x_1}}&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{W_{mi}x_i}}}{\partial{x_2}}&amp;amp;
\dots&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{W_{mi}x_i}}}{\partial{x_n}}
\end{bmatrix}=
\begin{bmatrix}
W_{11}&amp;amp;W_{12}&amp;amp;\dots&amp;amp;W_{1n}\\
W_{21}&amp;amp;W_{22}&amp;amp;\dots&amp;amp;W_{2n}\\
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\
W_{m1}&amp;amp;W_{m2}&amp;amp;\dots&amp;amp;W_{mn}\\
\end{bmatrix}=W
$$
如果是行向量的模式的话，计算公式变为了$\vec{y}=\vec{x}\bm{W}$，这里$W$的形状变成了$(N, M)$相应的计算展开式是
$$
\begin{bmatrix}
y_1 &amp;amp; y_2 &amp;amp; \dots &amp;amp; y_m
\end{bmatrix}=
\begin{bmatrix}
f_1(\bm{x}) &amp;amp;
f_2(\bm{x}) &amp;amp;
\dots &amp;amp;
f_m(\bm{x})
\end{bmatrix}=\nlspc
\begin{bmatrix}
f_1(x_1, x_2, &amp;hellip;, x_n) &amp;amp;
f_2(x_1, x_2, &amp;hellip;, x_n) &amp;amp;
\dots &amp;amp;
f_n(x_1, x_2, &amp;hellip;, x_n) &amp;amp;
\end{bmatrix}=\nlspc
\begin{bmatrix}
x_1W_{11}+x_2W_{21}+\dots+x_nW_{n1} &amp;amp;
x_1W_{12}+x_2W_{22}+\dots+x_nW_{n2} &amp;amp;
\dots &amp;amp;
x_1W_{1m}+x_2W_{2m}+\dots+x_nW_{nm}
\end{bmatrix}=\nlspc
\begin{bmatrix}
\sum\limits_{i=1}^{N}{x_iW_{i1}}&amp;amp;
\sum\limits_{i=1}^{N}{x_iW_{i2}}&amp;amp;
\dots &amp;amp;
\sum\limits_{i=1}^{N}{x_iW_{im}}
\end{bmatrix}
$$
注意行向量的结果已经被占据行了，因此其导数矩阵应该往下延伸，也就是
$$
\frac{\partial{\vec{y}}}{\partial{\vec{x}}}=
\begin{bmatrix}
\frac{\partial{\sum\limits_{i=1}^{N}{x_iW_{i1}}}}{\partial{x_1}}&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{x_iW_{i2}}}}{\partial{x_2}}&amp;amp;
\dots
\frac{\partial{\sum\limits_{i=1}^{N}{W_{1i}x_i}}}{\partial{x_n}}\nlspc
\frac{\partial{\sum\limits_{i=1}^{N}{W_{2i}x_i}}}{\partial{x_1}}&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{W_{2i}x_i}}}{\partial{x_2}}&amp;amp;
\dots
\frac{\partial{\sum\limits_{i=1}^{N}{W_{2i}x_i}}}{\partial{x_n}}\nlspc
\vdots \nlspc
\frac{\partial{\sum\limits_{i=1}^{N}{W_{mi}x_i}}}{\partial{x_1}}&amp;amp;
\frac{\partial{\sum\limits_{i=1}^{N}{W_{mi}x_i}}}{\partial{x_2}}&amp;amp;
\dots
\frac{\partial{\sum\limits_{i=1}^{N}{W_{mi}x_i}}}{\partial{x_n}}\nlspc
\end{bmatrix}=
\begin{bmatrix}
W_{11}&amp;amp;W_{12}&amp;amp;\dots&amp;amp;W_{1n}\\
W_{21}&amp;amp;W_{22}&amp;amp;\dots&amp;amp;W_{2n}\\
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\
W_{m1}&amp;amp;W_{m2}&amp;amp;\dots&amp;amp;W_{mn}\\
\end{bmatrix}=W
$$&lt;/p>
&lt;h2 id="向量对矩阵求导">向量对矩阵求导&lt;/h2>
&lt;p>向量和矩阵的乘积是一个向量，怎么求向量对矩阵的导数呢？我们考察一下batch个input向量的情形&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>，也就是假设一个神经元$\bm{w}$，m张图片输入记做$\bm{X}$，其形状是$(M, N)$：
$$
X=
\begin{bmatrix}
\vec{x_1},\vec{x_2},\dots,\vec{x_m}
\end{bmatrix}^\intercal=
\begin{bmatrix}
x_{11}&amp;amp;x_{12}&amp;amp;\dots&amp;amp;x_{1n}\nlspc
x_{21}&amp;amp;x_{22}&amp;amp;\dots&amp;amp;x_{2n}\nlspc
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\nlspc
x_{m1}&amp;amp;x_{m2}&amp;amp;\dots&amp;amp;x_{mn}
\end{bmatrix}
$$
$\vec{y}$的计算方法是
$$
\vec{y}=\bm{X}\vec{w}=\nlspc
\begin{bmatrix}
x_{11}&amp;amp;x_{12}&amp;amp;\dots&amp;amp;x_{1n}\nlspc
x_{21}&amp;amp;x_{22}&amp;amp;\dots&amp;amp;x_{2n}\nlspc
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\nlspc
x_{m1}&amp;amp;x_{m2}&amp;amp;\dots&amp;amp;x_{mn}
\end{bmatrix}
\begin{bmatrix}
w_1 \nlspc w_2 \nlspc \vdots \nlspc w_n
\end{bmatrix}=
\begin{bmatrix}
y_1 \nlspc y_2 \nlspc \vdots \nlspc y_m
\end{bmatrix}
$$
则$\pdiff{\vec{y}}{\bm{X}}$为
$$
\pdiff{\vec{y}}{\bm{X}}=
\begin{bmatrix}
\pdiff{y_1}{\bm{X}}\nlspc
\pdiff{y_2}{\bm{X}}\nlspc
\vdots\nlspc
\pdiff{y_m}{\bm{X}}\nlspc
\end{bmatrix}
$$
其形状为$(M, M, N)$，其最终的形式怎么排似乎没有定论。&lt;/p>
&lt;h2 id="矩阵对矩阵求导">矩阵对矩阵求导&lt;/h2>
&lt;p>更复杂的情况是不仅input带上来batch，神经元也有了多个，这个时候输出也变成了矩阵，我们假设有K个神经元，其他形状跟上面一样不变，则有：
$$
\bm{Y_{M,K}}=\bm{X_{M,N}}\bm{W_{N,K}}=\nlspc
\begin{bmatrix}
x_{11}&amp;amp;x_{12}&amp;amp;\dots&amp;amp;x_{1n}\nlspc
x_{21}&amp;amp;x_{22}&amp;amp;\dots&amp;amp;x_{2n}\nlspc
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\nlspc
x_{m1}&amp;amp;x_{m2}&amp;amp;\dots&amp;amp;x_{mn}
\end{bmatrix}
\begin{bmatrix}
w_{11}&amp;amp;w_{12}&amp;amp;\dots&amp;amp;w_{1k} \nlspc
w_{21}&amp;amp;w_{22}&amp;amp;\dots&amp;amp;w_{2k} \nlspc
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\nlspc
w_{n1}&amp;amp;w_{n2}&amp;amp;\dots&amp;amp;w_{nk} \nlspc
\end{bmatrix}=
\begin{bmatrix}
y_{11}&amp;amp;y_{12}&amp;amp;\dots&amp;amp;y_{1k}\nlspc
y_{21}&amp;amp;y_{22}&amp;amp;\dots&amp;amp;y_{2k}\nlspc
\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\nlspc
y_{m1}&amp;amp;y_{m2}&amp;amp;\dots&amp;amp;y_{mk}
\end{bmatrix}
$$
如果再按照雅各比矩阵的方式排列，得到的导数$\pdiff{\bm{Y}}{\bm{X}}$的形状就变成了$(M, K, M, N)$&lt;/p>
&lt;p>到这里就可以发现我们在深度学习的模型中使用了batch，那么输出输出都可能是矩阵，如果应用链式法则去求梯度就会出现高维偏导矩阵，高维偏导矩阵先不说排布没有统一，即便统一了概念也非常难以理解&lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>，即便理解了也不具有实践意义计算量也会非常的大，那有什么优化的方法呢？我们观察到不直接求导而是求导数乘以方向向量会大量简化计算。&lt;/p>
&lt;h1 id="求梯度">求梯度&lt;/h1>
&lt;p>回忆一下，梯度是多元变量函数中输出标量对于输入参数的导数，我们在&lt;a href="#梯度gradient">梯度&lt;/a>这一节知道了梯度的基本形式，也就是对于函数$f:\R^n \mapsto \R$，其对输入向量$\vec{x}$的梯度记为：
$$
\nabla f=
\begin{bmatrix}
\pdiff{f}{x_1} \nlspc
\pdiff{f}{x_2} \nlspc
\vdots \nlspc
\pdiff{f}{x_n}
\end{bmatrix}
$$
这里&lt;code>梯度的维度和输入向量的维度是一致的&lt;/code>。&lt;/p>
&lt;p>假设存在函数$f: \R^n \mapsto \R^m$，这个函数由如下几个函数组合而成
$$
\vec{y}=\vec{f_4}(\vec{f_3}(\vec{f_2}(\vec{f_1}(\vec{x}))))
$$
其中$f_1: \R^n \mapsto \R^{m_1}, f_2: \R^{m_1} \mapsto \R^{m_2}, f_3: \R^{m_2} \mapsto \R^{m_3}, f_4: \R^{m_3} \mapsto \R^{m}$
如果求$\vec{y}$对$\vec{x}$的Jacobian的话，根据链式求导法则有
$$
\begin{align*}
J_f(\vec{x})_{m,n}=\pdiff{\vec{y}}{\vec{x}}
&amp;amp;=\pdiff{\vec{y}}{\vec{x_4}}\pdiff{\vec{x_4}}{\vec{x_3}}\pdiff{\vec{x_3}}{\vec{x_2}}\pdiff{\vec{x_2}}{\vec{x}}\nlspc
&amp;amp;=\pdiff{\vec{f_4}}{\vec{x_4}}\pdiff{\vec{f_3}}{\vec{x_3}}\pdiff{\vec{f_2}}{\vec{x_2}}\pdiff{\vec{f_1}}{\vec{x}}\nlspc
&amp;amp;=J{_f{_4}}J{_f{_3}}J{_f{_2}}J{_f{_1}}
\end{align*}
$$
可以看到最后就变成了一个矩阵连乘的最优化问题，虽然是可以用动态规划求得最优解，但是在实际中我们只考虑两种模式也就是forward和backward。&lt;/p>
&lt;h2 id="正向模式forward">正向模式(Forward)&lt;/h2>
&lt;p>正向模式就是我们先用&lt;a href="#jvpjacobian-vector-product">JVP&lt;/a>的方式右乘一个单位方向向量$\vec{v} \in \R^n$，每次只求Jacobian的一列，因为是右乘所以按照$J{_f{_1}}$接着$J{_f{_2}}$的方式直到所有的导数都计算出来就更加的高效，因为每次都只计算一列，一共有n列，就要循环n次才能将整个Jacobian计算出来。&lt;/p>
&lt;p>计算过程的形状为
$$
\begin{align*}
J_f(\vec{x})_{m,n}\vec{v}=\underleftarrow{J{_f{_4}}J{_f{_3}}J{_f{_2}}J{_f{_1}}\vec{v}}
&amp;amp;=(m, m_3)(m_3, m_2)(m_2, m_1)\undergroup{(m_1, n)(n, 1)} \\
&amp;amp;=(m, m_3)(m_3, m_2)\undergroup{(m_2, m_1)(m_1, 1)} \\
&amp;amp;=(m, m_3)\undergroup{(m_3, m_2)(m_2, 1)} \\
&amp;amp;=\undergroup{(m, m_3)(m_3, 1)} \\
&amp;amp;=(m, 1)
\end{align*}
$$
从右到左计算矩阵，单次的计算量为$m_1n+m_2m_1+m_3m_2+mm_3$，要计算n次，所以总的计算量为
$$
n(m_1n+m_2m_1+m_3m_2+mm_3)
$$&lt;/p>
&lt;p>前向模式的优点是可以一次计算完结果和Jacobian不需要保存中间结果，算法如下：&lt;/p>
&lt;blockquote class="framed">&lt;p>$\vec{f}(\vec{x})=\vec{f_K}\circ\dots\circ\vec{f_2}\circ\vec{f_1}$&lt;br>
$[\bm{J}_{\vec{f}}(\vec{x})]_{:,j}=\bm{J}_{\vec{f}_K}(\vec{x}_K)\dots \bm{J}_{\vec{f}_2}(\vec{x}_2) \bm{J}_{\vec{f}_1}(\vec{x}_1)\vec{e}_j, j \in {1,\dots,n}$&lt;/p>
&lt;p>&lt;strong>Input&lt;/strong>: $\vec{x} \in \R^n$&lt;/p>
&lt;p>$\vec{x_1} \leftarrow \vec{x}$&lt;br>
$\vec{v_j} \leftarrow \vec{e}_j \in \R^n, j \in {1,\dots,n}$&lt;/p>
&lt;p>&lt;em>&lt;strong>for&lt;/strong>&lt;/em> k = 1 to K &lt;em>&lt;strong>do&lt;/strong>&lt;/em>&lt;br>
$\quad\vec{x}_{k+1} \leftarrow \vec{f_k}(\vec{x}_k)$&lt;br>
$\quad\vec{v_j} \leftarrow \bm{J}_{\vec{f}_k}(\vec{x_k})\vec{v_j}$&lt;br>
&lt;em>&lt;strong>end for&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Returns&lt;/strong>&lt;/em>: $\vec{x}_{K+1}, [\bm{J}_f(\vec{x})]_{:,j}=\vec{v_j}, j \in {1,\dots,n}$&lt;/p>
&lt;/blockquote>
&lt;p>我们用一个简单的例子来验证一下JVP计算的过程，使用的函数较为$\vec{f}=f_3(\vec{f}_2(\vec{f}_1(\vec{x}))),~where ~\vec{f}_1: exp(\vec{x}),~\vec{f}_2: tanh(\vec{x}),~f_3=sum(\vec{x})$，值得注意的点是在求$f_1,~f_2$的JVP的时候我们没有直接求出来Jacobian，然后使用矩阵乘以向量的方式，而是使用了两个向量相乘的形式，这是因为对对$\vec{f}_1$类似于逐元素求导，也就是只有对角线有值其他都为0，而$\vec{v}$又是一个列向量，相乘之后还是一个向量，效果相当于两个向量逐元素乘。从这个角度看也证明了我们在引入方向向量$\vec{v}$之后并不需要计算完整的Jacobian，因此减少了计算量：
$$
\pdiff{\vec{f}_1}{\vec{x}}\vec{v}=
\begin{bmatrix}
exp^{x_1}&amp;amp; 0&amp;amp; 0&amp;amp; 0\nlspc
0&amp;amp; exp^{x_2}&amp;amp; 0&amp;amp; 0\nlspc
0&amp;amp; 0&amp;amp; exp^{x_3}&amp;amp; 0\nlspc
0&amp;amp; 0&amp;amp; 0&amp;amp; exp^{x_4}\nlspc
\end{bmatrix}
\begin{bmatrix}
v_1\nlspc
v_2\nlspc
v_3\nlspc
v_4\nlspc
\end{bmatrix}=
\begin{bmatrix}
exp^{x_1}v_1\nlspc
exp^{x_2}v_2\nlspc
exp^{x_3}v_3\nlspc
exp^{x_4}v_4\nlspc
\end{bmatrix}=\pdiff{f}{\vec{x}}\odot\vec{v}
$$&lt;/p>
&lt;p>而对于$f_3$，其左边是一个$(1, 4)$的Jacobian，右边是一个$(4, 1)$的方向向量，用矩阵乘就可以了，但是实现的时候都因为都是1D的向量，所以直接用了两个向量的点乘。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f1&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">jvp&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> v&lt;span style="color:#f92672">*&lt;/span>torch&lt;span style="color:#f92672">.&lt;/span>exp(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> jvp, torch&lt;span style="color:#f92672">.&lt;/span>exp(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f2&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">jvp&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> v&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>torch&lt;span style="color:#f92672">.&lt;/span>tanh(x)&lt;span style="color:#f92672">*&lt;/span>torch&lt;span style="color:#f92672">.&lt;/span>tanh(x))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> jvp, torch&lt;span style="color:#f92672">.&lt;/span>tanh(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f3&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">jvp&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>ones_like(x)&lt;span style="color:#f92672">.&lt;/span>dot(v&lt;span style="color:#f92672">.&lt;/span>T)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> jvp, torch&lt;span style="color:#f92672">.&lt;/span>sum(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">1.&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>es &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>eye(len(x), len(x))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fs &lt;span style="color:#f92672">=&lt;/span> [f1, f2, f3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>o &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jab &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> v &lt;span style="color:#f92672">in&lt;/span> es:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xi &lt;span style="color:#f92672">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> fs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jvp, o &lt;span style="color:#f92672">=&lt;/span> f(xi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xi &lt;span style="color:#f92672">=&lt;/span> o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v &lt;span style="color:#f92672">=&lt;/span> jvp(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jab&lt;span style="color:#f92672">.&lt;/span>append(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jab &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>column_stack(jab)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#39;output:&amp;#39;&lt;/span>, o)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#39;jacobian:&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>, jab)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># output: tensor(3.9913)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># jacobian:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># tensor([[4.6937e-02, 1.1451e-05, 0.0000e+00, 0.0000e+00]])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(x): &lt;span style="color:#66d9ef">return&lt;/span> f3(f2(f1(x)[&lt;span style="color:#ae81ff">1&lt;/span>])[&lt;span style="color:#ae81ff">1&lt;/span>])[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_o &lt;span style="color:#f92672">=&lt;/span> f(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_jab &lt;span style="color:#f92672">=&lt;/span> jacobian(f, x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#39;output:&amp;#39;&lt;/span>, o)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#39;jacobian:&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>, jab)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>torch&lt;span style="color:#f92672">.&lt;/span>allclose(o, _o)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>torch&lt;span style="color:#f92672">.&lt;/span>allclose(jab, _jab)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="反向模式backward">反向模式(Backward)&lt;/h2>
&lt;p>反向模式就是我们先用&lt;a href="#vjpvector-jacobian-product">VJP&lt;/a>的方式用一个单位方向向量$\vec{v}\in\R^m$右乘最后一个偏导，每次只求Jacobian的一行，因为是单位向量在左边右乘所以按照$J{_f{_4}}$接着$J{_f{_3}}$的方式直到所有的导数都计算出来就更加的高效，因为每次都只计算一行，一共有m列，就要循环m次才能将整个Jacobian计算出来。&lt;/p>
&lt;p>计算过程的形状为
$$
\begin{align*}
\vec{v}J_f(\vec{x})_{m,n}=\underrightarrow{\vec{v}J{_f{_4}}J{_f{_3}}J{_f{_2}}J{_f{_1}}}
&amp;amp;=\undergroup{(1, m)(m, m_3)}(m_3, m_2)(m_2, m_1)(m_1, n) \\
&amp;amp;=\undergroup{(1, m_3)(m_3, m_2)}(m_2, m_1)(m_1, n) \\
&amp;amp;=\undergroup{(1, m_2)(m_2, m_1)}(m_1, n) \\
&amp;amp;=\undergroup{(1, m_1)(m_1, n)} \\
&amp;amp;=(1, n)
\end{align*}
$$
从左到右计算矩阵，单次的计算量也为$m_1n+m_2m_1+m_3m_2+mm_3$，只不过顺序要倒过来，要计算m次，所以总的计算量为
$$
m(m_1n+m_2m_1+m_3m_2+mm_3)
$$
但是这里m通常取1，也就是一个向量最终会对应一个损失函数计算出来的标量，也就是计算的复杂度可以降到$O(n^2)$&lt;/p>
&lt;p>反向模式的则需要先前项走一遍得到所有的中间结果，然后再利用中间结果反向走一遍得到最终的梯度，算法如下：&lt;/p>
&lt;blockquote class="framed">&lt;p>$\vec{f}(\vec{x})=\vec{f_K}\circ\dots\circ\vec{f_2}\circ\vec{f_1}$&lt;br>
$[\bm{J}_{\vec{f}}(\vec{x})]_{i,:}=\vec{e}_i^\intercal \bm{J}_{\vec{f}_K}(\vec{x}_K)\dots \bm{J}_{\vec{f}_2}(\vec{x}_2) \bm{J}_{\vec{f}_1}(\vec{x}) \quad i \in {1,\dots,m}$&lt;/p>
&lt;p>&lt;strong>Input&lt;/strong>: $\vec{x} \in \R^n$&lt;/p>
&lt;p>$\vec{x_1} \leftarrow \vec{x}$&lt;br>
$\vec{u_i} \leftarrow \vec{e}_i \in \R^m \quad i \in {1,\dots,m}$&lt;/p>
&lt;p>&lt;em>&lt;strong>for&lt;/strong>&lt;/em> k = 1 to K &lt;em>&lt;strong>do&lt;/strong>&lt;/em>&lt;br>
$\quad\vec{x}_{k+1} \leftarrow \vec{f}_k(\vec{x}_k)$&lt;br>
&lt;em>&lt;strong>end for&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>for&lt;/strong>&lt;/em> k = K to 1 &lt;em>&lt;strong>do&lt;/strong>&lt;/em>&lt;br>
$\quad\vec{u_i}^\intercal \leftarrow \vec{u_i}^\intercal \bm{J}_{\vec{f}_k}(\vec{x_k}) \quad i \in {1,\dots,m}$&lt;br>
&lt;em>&lt;strong>end for&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Returns&lt;/strong>&lt;/em>: $\vec{x}_{K+1}, [\bm{J}_f(\vec{x})]_{i,:}=\vec{u_i}^\intercal \quad i \in {1,\dots,m}$&lt;/p>
&lt;/blockquote>
&lt;p>我们仍然使用上面的例子，不过这次变成使用反向的模式。这里有几个不同，首先是$f_3$，它是一个reduction，Jacobian的形状是$(1, 4)$，方向向量的是根据输出来的也就是$(1, 1)$，得到一个$(1, 4)$的结果，但是因为是1D向量，这里简化成了向量逐元素乘。&lt;/p>
&lt;p>另外一个显著不同是，我们先跑一遍前向模式，保存每一层的中间结果，这是因为在反向VJP的时候的时候我们要使用当前层的输入，也就是上一层的输出，实现的时候我们利用一个数组保存所有的中间结果，到某一层的时候我们从数组里边拿到上一层的输出即可。&lt;/p>
&lt;p>还有一个需要显著说明的是，这里的&lt;code>es&lt;/code>其实只有1D，因为最终的结果是一个标量，我们只用计算一次就可以了，而不是像JVP一样的4次。&lt;/p>
&lt;p>另外可以看到，其他两个函数我们计算VJP和JVP的方法是一样的，这是因为不论我们左乘一个方向向量还是右乘一个方向向量，得到的都是跟对角线的逐元素乘积，最后的Jacobian是对称的矩阵。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f3&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">vjp&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> v&lt;span style="color:#f92672">*&lt;/span>torch&lt;span style="color:#f92672">.&lt;/span>ones_like(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> vjp, torch&lt;span style="color:#f92672">.&lt;/span>sum(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> tensor([&lt;span style="color:#ae81ff">1.&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xi &lt;span style="color:#f92672">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>os &lt;span style="color:#f92672">=&lt;/span> [x]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fs &lt;span style="color:#f92672">=&lt;/span> [f1, f2, f3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> fs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _, o &lt;span style="color:#f92672">=&lt;/span> f(xi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os&lt;span style="color:#f92672">.&lt;/span>append(o)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xi &lt;span style="color:#f92672">=&lt;/span> o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>os &lt;span style="color:#f92672">=&lt;/span> os[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dim &lt;span style="color:#f92672">=&lt;/span> len(o) &lt;span style="color:#66d9ef">if&lt;/span> o&lt;span style="color:#f92672">.&lt;/span>dim() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>es &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>eye(dim, dim)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jab &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> v &lt;span style="color:#f92672">in&lt;/span> es:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> reversed(range(len(fs))):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vjp, _ &lt;span style="color:#f92672">=&lt;/span> fs[i](os[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v &lt;span style="color:#f92672">=&lt;/span> vjp(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jab&lt;span style="color:#f92672">.&lt;/span>append(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jab &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>row_stack(jab)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#39;output:&amp;#39;&lt;/span>, o)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#39;jacobian:&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>, jab)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="jvp和vjp的比较">JVP和VJP的比较&lt;/h2>
&lt;p>考虑一般情形，对于函数$\bm{F}: \R^n \mapsto \R^m$，如果$m \gg n$，Jacobian的函数的行数比列数多那么使用JVP比较高效，因为JVP每次计算一列也就是m个数，计算的数据更多；相反如果$n \gg m$，这个时候Jacobian有更多的列，那么一次计算一行效率更高也就是一次算出来n个元素，使用VJP效率更高&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>。在深度学习的大多数场景下都是从一个高维Tensor映射到一个标量，也就是$n \gg m$的情形，这时候就更适合使用VJP模式了。从上面的简单代码也可以看出来VJP是减少了将近3/4的运算，但是缺点就是需要保存中间结果。&lt;/p>
&lt;h2 id="带batch的高纬求梯度">带batch的高纬求梯度&lt;/h2>
&lt;p>所有之前的讨论我们都是假设输入是一个向量$|\vec{x}|=n$，因为在求导的时候我们看到了高纬矩阵的偏导数非常复杂，但是考虑到深度学习的输出都是一个$Loss$函数也就是一个标量，最终梯度也是标量对矩阵的导数，再结合VJP的方式高纬求梯度就可以实现了（事实上，如果输出$m=1$的话我们不用再左乘一个单位向量，因为左乘的是$1 \times 1$的向量）。&lt;/p>
&lt;p>我们把例子的前后向形状变化表示出来，前向如下：
$$
\underbrace{\vec{x}}_{1 \times 4} \xrightarrow{\overrightarrow{exp}}
\underbrace{\vec{x}_1}_{1 \times 4} \xrightarrow{\overrightarrow{tanh}}
\underbrace{\vec{x}_2}_{1 \times 4} \xrightarrow{sum}
\underbrace{y}_1
$$&lt;/p>
&lt;p>反向如下：
$$
\underbrace{\pdiff{y}{\vec{x}}}_{1 \times 4}
\xleftarrow{\underbrace{\pdiff{\vec{x}_1}{\vec{x}}}_{4 \times 4}} \underbrace{\pdiff{y}{\vec{x}_1}}_{1 \times 4}
\xleftarrow{\underbrace{\pdiff{\vec{x}_2}{\vec{x}_1}}_{4 \times 4}} \underbrace{\pdiff{y}{\vec{x}_2}}_{1 \times 4}
\xleftarrow{sum} \underbrace{dy}_{1 \times 1}
$$&lt;/p>
&lt;p>虽然这里写上了对$tanh$和$exp$的偏导数是$4 \times 4$的矩阵，但是实际上我们只算了对角线跟后面来的方向向量的逐元素乘，如果将上面的矩阵乘变成逐元素乘，反向的过程如下：
$$
\underbrace{\pdiff{y}{\vec{x}}}_{1 \times 4}
\xleftarrow{\odot ~\underbrace{Diag(\pdiff{\vec{x}_1}{\vec{x}})}_{1 \times 4}} \underbrace{\pdiff{y}{\vec{x}_1}}_{1 \times 4}
\xleftarrow{\odot ~\underbrace{Diag(\pdiff{\vec{x}_2}{\vec{x}_1})}_{1 \times 4}} \underbrace{\pdiff{y}{\vec{x}_2}}_{1 \times 4}
\xleftarrow{sum} \underbrace{dy}_{1 \times 1}
$$&lt;/p>
&lt;p>当我们把输入的向量扩展成2D，正向的过程就变为了：
$$
\underbrace{\bm{X}}_{2 \times 4} \xrightarrow{\overrightarrow{exp}}
\underbrace{\bm{X}_1}_{2 \times 4} \xrightarrow{\overrightarrow{tanh}}
\underbrace{\bm{X}_2}_{2 \times 4} \xrightarrow{sum}
\underbrace{y}_1
$$&lt;/p>
&lt;p>反向变成了下面的形式，我们在求导的章节已经说过矩阵对矩阵的求导形式是不定的：
$$
\underbrace{\pdiff{y}{\bm{X}}}_{2 \times 4}
\xleftarrow{\underbrace{\pdiff{\bm{X}_1}{\bm{X}}}_{2 \times 4 \times 2 \times 4}} \underbrace{\pdiff{y}{\bm{X}_1}}_{2 \times 4}
\xleftarrow{\underbrace{\pdiff{\bm{X}_2}{\bm{X}_1}}_{2 \times 4 \times 2 \times 4}} \underbrace{\pdiff{y}{\bm{X}_2}}_{2 \times 4}
\xleftarrow{sum} \underbrace{dy}_{1 \times 1}
$$&lt;/p>
&lt;p>这里我们观察发现输出的两个通道之间根本就没有关系，可以看作是独立的两部分放到了一起而已，这样就会变成如下的形式：
$$
\underbrace{\pdiff{y}{\bm{X}}}_{2 \times 4}
\xleftarrow{\odot ~\underbrace{Diag(\pdiff{\bm{X}_1}{\bm{X}}}_{2 \times 4})} \underbrace{\pdiff{y}{\bm{X}_1}}_{2 \times 4}
\xleftarrow{\odot ~\underbrace{Diag(\pdiff{\bm{X}_2}{\bm{X}_1}}_{2 \times 4})} \underbrace{\pdiff{y}{\bm{X}_2}}_{2 \times 4}
\xleftarrow{sum} \underbrace{dy}_{1 \times 1}
$$&lt;/p>
&lt;p>如果用个例子来验证的话，可以发现只用将输入再加一个batch就可以了，代码不用做任何变化：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f1&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">vjp&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> v&lt;span style="color:#f92672">*&lt;/span>torch&lt;span style="color:#f92672">.&lt;/span>exp(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> vjp, torch&lt;span style="color:#f92672">.&lt;/span>exp(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f2&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">vjp&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> v&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>torch&lt;span style="color:#f92672">.&lt;/span>tanh(x)&lt;span style="color:#f92672">*&lt;/span>torch&lt;span style="color:#f92672">.&lt;/span>tanh(x))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> vjp, torch&lt;span style="color:#f92672">.&lt;/span>tanh(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f3&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">vjp&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> v&lt;span style="color:#f92672">*&lt;/span>torch&lt;span style="color:#f92672">.&lt;/span>ones_like(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> vjp, torch&lt;span style="color:#f92672">.&lt;/span>sum(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> tensor([[&lt;span style="color:#ae81ff">1.&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>], [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xi &lt;span style="color:#f92672">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>os &lt;span style="color:#f92672">=&lt;/span> [x]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fs &lt;span style="color:#f92672">=&lt;/span> [f1, f2, f3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> fs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _, o &lt;span style="color:#f92672">=&lt;/span> f(xi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os&lt;span style="color:#f92672">.&lt;/span>append(o)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xi &lt;span style="color:#f92672">=&lt;/span> o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>os &lt;span style="color:#f92672">=&lt;/span> os[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dim &lt;span style="color:#f92672">=&lt;/span> len(o) &lt;span style="color:#66d9ef">if&lt;/span> o&lt;span style="color:#f92672">.&lt;/span>dim() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>es &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>eye(dim, dim)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jab &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> v &lt;span style="color:#f92672">in&lt;/span> es:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> reversed(range(len(fs))):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vjp, _ &lt;span style="color:#f92672">=&lt;/span> fs[i](os[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v &lt;span style="color:#f92672">=&lt;/span> vjp(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jab&lt;span style="color:#f92672">.&lt;/span>append(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jab &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>row_stack(jab)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#39;output:&amp;#39;&lt;/span>, o)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#39;jacobian:&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>, jab)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># output: tensor(7.9827)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># jacobian:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># tensor([[4.6937e-02, 1.1451e-05, 0.0000e+00, 0.0000e+00],&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [4.6937e-02, 1.1451e-05, 0.0000e+00, 0.0000e+00]])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="特殊算子求梯度">特殊算子求梯度&lt;/h2>
&lt;p>上面的部分我们只涉及了一类逐元素求值的算子，也就是Unary算子，求法上我们使用了对角阵乘向量相当于两个向量逐点乘这样一种观察，但是这种观察只能对简单的算子有效，下面我们使用一种系统的方法来介绍一些不那么直观的算子怎么求梯度。&lt;/p>
&lt;p>首先，当然也要基于VJP的思路；其次，我们不用考虑batch，因为batch之间没有关系，只用简单的罗列就可以了。另外这里我们用的是行向量，因为用行向量跟代码对应起来比较直观，用列向量便于公式推导。对于一个算子来说其一般形式如下，其中只有橙色的部分是未知的，其他部分包括输入输出数据和操作都相当于已知的，而且大多时候反向的偏导矩阵是不用求的，可以直接根据和输出的梯度$g$的关系算出来，比如上面例子中的$exp$函数就直接用点乘替代就可以了。&lt;/p>
&lt;p>$$
\tag{forward} \underbrace{\vec{x}}_{1 \times n} \xrightarrow{\overrightarrow{op}}
\underbrace{\vec{o}}_{1 \times m}
$$&lt;/p>
&lt;p>$$
\tag{backward} {\color{#ffa86a}\underbrace{\pdiff{y}{\vec{x}}}_{1 \times n}}
\xleftarrow{\underbrace{\pdiff{\vec{o}}{\vec{x}}}_{m \times n}} \underbrace{\pdiff{y}{\vec{o}}}_{1 \times m}
$$&lt;/p>
&lt;h3 id="unary算子">Unary算子&lt;/h3>
&lt;p>下面的列表来自&lt;a href="https://github.com/HIPS/autograd/blob/c6d81ce7eede6db801d4e9a92b27ec5d409d0eab/autograd/numpy/numpy_vjps.py#L69-L142">aurograd&lt;/a>库，其中&lt;code>ans&lt;/code>表示当前算子的输出，&lt;code>x&lt;/code>表示当前算子的输入，&lt;code>g&lt;/code>表示输出标量对当前输出的梯度，&lt;code>*&lt;/code>表示点乘，&lt;code>/&lt;/code>表示点除。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Function&lt;/th>
&lt;th>Gradient&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>negative&lt;/td>
&lt;td>-g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>abs&lt;/td>
&lt;td>g * replace_zero(conj(x), 0.) / replace_zero(ans, 1.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fabs&lt;/td>
&lt;td>sign(x) * g) # fabs doesn&amp;rsquo;t take complex numbers.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>absolute&lt;/td>
&lt;td>g * conj(x) / ans&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>reciprocal&lt;/td>
&lt;td>- g / x**2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>exp&lt;/td>
&lt;td>ans * g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>exp2&lt;/td>
&lt;td>ans * log(2) * g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>expm1&lt;/td>
&lt;td>(ans + 1) * g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>log&lt;/td>
&lt;td>g / x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>log2&lt;/td>
&lt;td>g / x / log(2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>log10&lt;/td>
&lt;td>g / x / log(10)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>log1p&lt;/td>
&lt;td>g / (x + 1)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sin&lt;/td>
&lt;td>g * cos(x)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cos&lt;/td>
&lt;td>- g * sin(x)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tan&lt;/td>
&lt;td>g / cos(x) **2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>arcsin&lt;/td>
&lt;td>g / sqrt(1 - x**2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>arccos&lt;/td>
&lt;td>g / sqrt(1 - x**2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>arctan&lt;/td>
&lt;td>g / (1 + x**2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sinh&lt;/td>
&lt;td>g * cosh(x)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cosh&lt;/td>
&lt;td>g * sinh(x)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tanh&lt;/td>
&lt;td>g / cosh(x) **2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>arcsinh&lt;/td>
&lt;td>g / sqrt(x**2 + 1)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>arccosh&lt;/td>
&lt;td>g / sqrt(x**2 - 1)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>arctanh&lt;/td>
&lt;td>g / (1 - x**2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rad2deg&lt;/td>
&lt;td>g / pi * 180.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>degrees&lt;/td>
&lt;td>g / pi * 180.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>deg2rad&lt;/td>
&lt;td>g * pi / 180.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>radians&lt;/td>
&lt;td>g * pi / 180.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>square&lt;/td>
&lt;td>g * 2 * x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sqrt&lt;/td>
&lt;td>g * 0.5 * x**-0.5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sinc&lt;/td>
&lt;td>g * (cos(pi&lt;em>x)&lt;em>pi&lt;/em>x - sin(pi&lt;/em>x))/(pi*x**2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>reshape&lt;/td>
&lt;td>lambda ans, x, shape, order=None : reshape(g, shape(x), order=order)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>roll&lt;/td>
&lt;td>lambda ans, x, shift, axis=None : roll(g, -shift, axis=axis)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>array_split&lt;/td>
&lt;td>lambda ans, ary, idxs, axis=0 : concatenate(g, axis=axis)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>split&lt;/td>
&lt;td>lambda ans, ary, idxs, axis=0 : concatenate(g, axis=axis)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>vsplit&lt;/td>
&lt;td>lambda ans, ary, idxs : concatenate(g, axis=0)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>hsplit&lt;/td>
&lt;td>lambda ans, ary, idxs : concatenate(g, axis=1)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dsplit&lt;/td>
&lt;td>lambda ans, ary, idxs : concatenate(g, axis=2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ravel&lt;/td>
&lt;td>lambda ans, x, order=None : reshape(g, shape(x), order=order)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>expand_dims&lt;/td>
&lt;td>lambda ans, x, axis : reshape(g, shape(x))&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>squeeze&lt;/td>
&lt;td>lambda ans, x, axis=None : reshape(g, shape(x))&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>diag&lt;/td>
&lt;td>lambda ans, x, k=0 : diag(g, k)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>flipud&lt;/td>
&lt;td>lambda ans, x, : flipud(g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fliplr&lt;/td>
&lt;td>lambda ans, x, : fliplr(g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rot90&lt;/td>
&lt;td>lambda ans, x, k=1 : rot90(g, -k)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>trace&lt;/td>
&lt;td>lambda ans, x, offset=0 : einsum(&amp;lsquo;ij,&amp;hellip;-&amp;gt;ij&amp;hellip;&amp;rsquo;, eye(x.shape[0], x.shape[1], k=offset), g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>full&lt;/td>
&lt;td>lambda ans, shape, fill_value, dtype=None : sum(g), argnums=(1,)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>triu&lt;/td>
&lt;td>lambda ans, x, k=0 : triu(g, k=k)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tril&lt;/td>
&lt;td>lambda ans, x, k=0 : tril(g, k=k)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>clip&lt;/td>
&lt;td>lambda ans, x, a_min, a_max : g * logical_and(ans != a_min, ans != a_max)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>swapaxes&lt;/td>
&lt;td>lambda ans, x, axis1, axis2: swapaxes(g, axis2, axis1)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>moveaxis&lt;/td>
&lt;td>lambda ans, a, source, destination: moveaxis(g, destination, source)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>real_if_close&lt;/td>
&lt;td>match_complex(x, g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>real&lt;/td>
&lt;td>lambda ans, x : match_complex(x, g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>imag&lt;/td>
&lt;td>lambda ans, x : match_complex(x, -1j * g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>conj&lt;/td>
&lt;td>lambda ans, x : conj(g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>conjugate&lt;/td>
&lt;td>lambda ans, x: conj(g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>angle&lt;/td>
&lt;td>lambda ans, x : match_complex(x, g * conj(x * 1j) / abs(x)**2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>where&lt;/td>
&lt;td>None, lambda ans, c, x=None, y=None : where(c, g, zeros(g.shape)), lambda ans, c, x=None, y=None : where(c, zeros(g.shape), g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cross&lt;/td>
&lt;td>lambda ans, a, b, axisa=-1, axisb=-1, axisc=-1, axis=None : cross(b, g, axisb, axisc, axisa, axis), lambda ans, a, b, axisa=-1, axisb=-1, axisc=-1, axis=None : cross(g, a, axisc, axisa, axisb, axis)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>linspace&lt;/td>
&lt;td>lambda ans, start, stop, num : dot(linspace(1.0, 0.0, num), g), lambda ans, start, stop, num : dot(linspace(0.0, 1.0, num), g)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>_astype&lt;/td>
&lt;td>lambda ans, A, dtype, order=&amp;lsquo;K&amp;rsquo;, casting=&amp;lsquo;unsafe&amp;rsquo;, subok=True, copy=True: _astype(g, A.dtype)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="binary算子">Binary算子&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Function&lt;/th>
&lt;th>Gradient&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>add&lt;/td>
&lt;td>g, g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>multiply&lt;/td>
&lt;td>y * g, x * g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>subtract&lt;/td>
&lt;td>g, -g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>divide&lt;/td>
&lt;td>g / y, - g * x / y**2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>maximum&lt;/td>
&lt;td>g * balanced_eq(x, ans, y), g * balanced_eq(y, ans, x)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>minimum&lt;/td>
&lt;td>g * balanced_eq(x, ans, y), g * balanced_eq(y, ans, x)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fmax&lt;/td>
&lt;td>g * balanced_eq(x, ans, y), g * balanced_eq(y, ans, x)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fmin&lt;/td>
&lt;td>g * balanced_eq(x, ans, y), g * balanced_eq(y, ans, x)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>logaddexp&lt;/td>
&lt;td>g * anp.exp(x-ans), g * anp.exp(y-ans)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>logaddexp2&lt;/td>
&lt;td>g * 2**(x-ans), g * 2**(y-ans)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>true_divide&lt;/td>
&lt;td>g / y, - g * x / y**2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mod&lt;/td>
&lt;td>g, -g * anp.floor(x/y)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>remainder&lt;/td>
&lt;td>g, -g * anp.floor(x/y)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>power&lt;/td>
&lt;td>g * y * x ** anp.where(y, y - 1, 1.), g * anp.log(replace_zero(x, 1. * ans&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>arctan2&lt;/td>
&lt;td>g * y / (x&lt;strong>2 + y&lt;/strong>2), g * -x / (x&lt;strong>2 + y&lt;/strong>2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>hypot&lt;/td>
&lt;td>g * x / ans, g * y / ans&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="全连接算子">全连接算子&lt;/h3>
&lt;p>全连接的公式：
$$
\vec{y} = \bm{W}\vec{x}
$$
下面是全链接的一个简单例子
$$
\begin{array}{|c|c|c|c|}
\hline W_{11} &amp;amp; W_{12} &amp;amp; W_{13} &amp;amp; W_{14} \\
\hline W_{21} &amp;amp; W_{22} &amp;amp; W_{23} &amp;amp; W_{24} \\
\hline W_{31} &amp;amp; W_{32} &amp;amp; W_{33} &amp;amp; W_{34} \\
\hline
\end{array} \times
\begin{array}{|c|}
\hline x_1 \\
\hline x_2 \\
\hline x_3 \\
\hline x_4 \\
\hline
\end{array} =
\begin{array}{|c|}
\hline y_1 \\
\hline y_2 \\
\hline y_3 \\
\hline
\end{array}
$$
分解每一项我们得到
$$
y_1 = W_{11}x_1 + W_{12}x_2 + W_{13}x_3 + W_{14}x_4 \newline
y_2 = W_{21}x_1 + W_{22}x_2 + W_{23}x_3 + W_{24}x_4 \newline
y_3 = W_{31}x_1 + W_{32}x_2 + W_{33}x_3 + W_{34}x_4 \newline
$$&lt;/p>
&lt;p>我们先来计算$W_{11}$的梯度，我们发现$W_{11}$只跟$y_1$一项有关，因此有
$$
\pdiff{J}{W_{11}} = \pdiff{J}{y_1} \pdiff{y_1}{W_{11}} = \delta_{y_{1}} x_1
$$
同理，参数的每一项都只跟一个输出有关，因此我们有
$$
\pdiff{J}{W_{ij}} = \delta_{y_{i}} x_j
$$
也就是向量$\vec{y}$的梯度和向量$\vec{x}$的&lt;code>外积&lt;/code>：
$$
\empsym{\pdiff{J}{\bm{W}} = \Delta_{\vec{y}} \otimes \vec{x}}
$$
对输入向量$\vec{x}$的梯度，我们先看$x_1$，它跟对三个输出都有贡献，我们将三份贡献相加
$$
\pdiff{J}{x_1} = \pdiff{J}{y_1} \pdiff{y_1}{x_{1}} +
\pdiff{J}{y_2} \pdiff{y_2}{x_{1}} +
\pdiff{J}{y_3} \pdiff{y_3}{x_{1}} =
\delta_{y_{1}}W_{11} + \delta_{y_{2}}W_{21} +\delta_{y_{3}}W_{31}
$$&lt;/p>
&lt;p>这个很容易看出来就是$\bm{W}$的转置乘以$\vec{y}$的结果
$$
\empsym{\pdiff{J}{\vec{x}} = W^\intercal \Delta_{\vec{y}}}
$$&lt;/p>
&lt;p>代码验证一下可以直接用上面的模式验证，这里只写出关键部分：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fc_op&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fc&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">vjp&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> w&lt;span style="color:#f92672">.&lt;/span>T&lt;span style="color:#f92672">.&lt;/span>matmul(v), v&lt;span style="color:#f92672">.&lt;/span>outer(x) &lt;span style="color:#75715e"># x, w&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> vjp, w&lt;span style="color:#f92672">.&lt;/span>matmul(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vjp, y &lt;span style="color:#f92672">=&lt;/span> fc(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> g &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>ones_like(y) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dx, dw &lt;span style="color:#f92672">=&lt;/span> vjp(g)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> y, dx, dw
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="卷积算子">卷积算子&lt;/h3>
&lt;p>卷积的公式&lt;sup id="fnref:9">&lt;a href="#fn:9" class="footnote-ref" role="doc-noteref">9&lt;/a>&lt;/sup>
$$
\bm{Z} = \bm{W} \circledast \bm{A}+b \tag{0}
$$&lt;/p>
&lt;p>同样的我们找一个简单的例子用图示表示：
$$
\begin{array}{|c|c|c|c|}
\hline \empsym{a_{11}} &amp;amp; \empsym{a_{12}} &amp;amp; a_{13} \\
\hline \empsym{a_{21}} &amp;amp; \empsym{a_{22}} &amp;amp; a_{23} \\
\hline a_{31} &amp;amp; a_{32} &amp;amp; a_{33} \\
\hline
\end{array} \circledast
\begin{array}{|c|c|}
\hline \empsym{w_{11}} &amp;amp; \empsym{w_{12}} \\
\hline \empsym{w_{21}} &amp;amp; \empsym{w_{22}} \\
\hline
\end{array} =
\begin{array}{|c|c|}
\hline \empsym{z_{11}} &amp;amp; z_{12} \\
\hline z_{21} &amp;amp; z_{22} \\
\hline
\end{array}
$$&lt;/p>
&lt;p>我们将计算过程展开就有：
$$\empsym{z_{11} = w_{11} \cdot a_{11} + w_{12} \cdot a_{12} + w_{21} \cdot a_{21} + w_{22} \cdot a_{22} + b} \tag{1}$$
$$z_{12} = w_{11} \cdot a_{12} + w_{12} \cdot a_{13} + w_{21} \cdot a_{22} + w_{22} \cdot a_{23} + b \tag{2}$$
$$z_{21} = w_{11} \cdot a_{21} + w_{12} \cdot a_{22} + w_{21} \cdot a_{31} + w_{22} \cdot a_{32} + b \tag{3}$$
$$z_{22} = w_{11} \cdot a_{22} + w_{12} \cdot a_{23} + w_{21} \cdot a_{32} + w_{22} \cdot a_{33} + b \tag{4}$$&lt;/p>
&lt;p>求损失函数$J$对$a_{11}$的梯度：
$$\frac{\partial J}{\partial a_{11}}=\frac{\partial J}{\partial z_{11}} \frac{\partial z_{11}}{\partial a_{11}}=\delta_{z11}\cdot w_{11} \tag{5}$$&lt;/p>
&lt;p>再求损失函数$J$对$a_{12}$的梯度，我们从展开式中可以看到$a_{12}$对于$z_{11}, z_{12}$都有贡献，因此根据链式法则要叠加起来：
$$\frac{\partial J}{\partial a_{12}}=\frac{\partial J}{\partial z_{11}} \frac{\partial z_{11}}{\partial a_{12}}+\frac{\partial J}{\partial z_{12}} \frac{\partial z_{12}}{\partial a_{12}}=\delta_{z11} \cdot w_{12}+\delta_{z12} \cdot w_{11} \tag{6}$$&lt;/p>
&lt;p>而$a_{22}$位于正中间，对4个部分都有贡献，因此有：
$$\frac{\partial J}{\partial a_{22}}=\frac{\partial J}{\partial z_{11}} \frac{\partial z_{11}}{\partial a_{22}}+\frac{\partial J}{\partial z_{12}} \frac{\partial z_{12}}{\partial a_{22}}+\frac{\partial J}{\partial z_{21}} \frac{\partial z_{21}}{\partial a_{22}}+\frac{\partial J}{\partial z_{22}} \frac{\partial z_{22}}{\partial a_{22}} \nlspc =\delta_{z11} \cdot w_{22} + \delta_{z12} \cdot w_{21} + \delta_{z21} \cdot w_{12} + \delta_{z22} \cdot w_{11} \tag{7}$$&lt;/p>
&lt;p>看一下图示，可以发现也是一个卷积的形式，只不过是卷积核和输出梯度的卷积：
$$
\begin{array}{|c|c|c|c|}
\hline \empsym{a_{11}} &amp;amp; a_{12} &amp;amp; a_{13} \\
\hline a_{21} &amp;amp; a_{22} &amp;amp; a_{23} \\
\hline a_{31} &amp;amp; a_{32} &amp;amp; a_{33} \\
\hline
\end{array} =
\begin{array}{|c|c|}
\hline \empsym{w_{11}} &amp;amp; \empsym{w_{12}} \\
\hline \empsym{w_{21}} &amp;amp; \empsym{w_{22}} \\
\hline
\end{array} \circledast
\begin{array}{|c|c|c|c|}
\hline \empsym{0} &amp;amp; \empsym{0} &amp;amp; 0 &amp;amp; 0 \\
\hline \empsym{0} &amp;amp; \empsym{z_{11}} &amp;amp; z_{12} &amp;amp; 0 \\
\hline 0 &amp;amp; z_{21} &amp;amp; z_{22} &amp;amp; 0 \\
\hline 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
\hline
\end{array}
$$
通过观察我们发现可以看作是卷积核旋转180度之后再与Delta-in做卷积的样子，这里因为是输出梯度的padding之后的矩阵，因此叫做Delta-in，公式是：
$$\empsym{\delta_{out} = \delta_{in} * W^{rot180} \tag{8}}$$
至于输出的梯度怎么padding，只需要考虑维度匹配即可，也就是$2 \times 2$的时候padding为1，$3 \times 3$的核，padding是2，$5 \times 5$的核，padding是4即可，也就是&lt;code>padding的大小是卷积核长度减一&lt;/code>。&lt;/p>
&lt;p>&lt;code>stride&lt;/code>对计算的影响？只需要将其看作stride为1，然后再计算的结果中间补0就可以了，也就是跟上面的类似，不过是在中心补0而不是边缘补0，补的大小呢就是&lt;code>stride-1&lt;/code>。&lt;/p>
&lt;p>卷积核个数对结果的影响？卷积核其实相当于batch，相当于多个神经元，有多个输出，也就是相互之间没什么影响，因此可以看作多个函数对输入的作用，那输入对最终的影响就是多份的，也就是要将几部分的影响加起来，通用公式就类似下面的叠加：
$$\delta_{out} = \sum_m \delta_{in_m} * W^{rot180}_ m \tag{9}$$&lt;/p>
&lt;p>输入个数对结果的影响？因为多个输入channel对应于多个卷积核的channel，实际发现其梯度只与其相作用的卷积核有关也就是，比如上面的图示扩展成两个channel，其计算过程如下：&lt;/p>
&lt;p>$$\begin{aligned}
z_{11} &amp;amp;= w_{111} \cdot a_{111} + w_{112} \cdot a_{112} + w_{121} \cdot a_{121} + w_{122} \cdot a_{122}
\\
&amp;amp;+ w_{211} \cdot a_{211} + w_{212} \cdot a_{212} + w_{221} \cdot a_{221} + w_{222} \cdot a_{222}
\end{aligned}
\tag{10}
$$&lt;/p>
&lt;p>$$
\begin{aligned}
z_{12} &amp;amp;= w_{111} \cdot a_{112} + w_{112} \cdot a_{113} + w_{121} \cdot a_{122} + w_{122} \cdot a_{123} \\
&amp;amp;+ w_{211} \cdot a_{212} + w_{212} \cdot a_{213} + w_{221} \cdot a_{222} + w_{222} \cdot a_{223}
\end{aligned}\tag{11}
$$&lt;/p>
&lt;p>$$
\begin{aligned}
z_{21} &amp;amp;= w_{111} \cdot a_{121} + w_{112} \cdot a_{122} + w_{121} \cdot a_{131} + w_{122} \cdot a_{132} \\
&amp;amp;+ w_{211} \cdot a_{221} + w_{212} \cdot a_{222} + w_{221} \cdot a_{231} + w_{222} \cdot a_{232}
\end{aligned}\tag{12}
$$&lt;/p>
&lt;p>$$
\begin{aligned}
z_{22} &amp;amp;= w_{111} \cdot a_{122} + w_{112} \cdot a_{123} + w_{121} \cdot a_{132} + w_{122} \cdot a_{133} \\
&amp;amp;+ w_{211} \cdot a_{222} + w_{212} \cdot a_{223} + w_{221} \cdot a_{232} + w_{222} \cdot a_{233}
\end{aligned}\tag{13}
$$&lt;/p>
&lt;p>对$a_{122}$求导过程如下：
$$\begin{aligned}
\frac{\partial J}{\partial a_{111}}&amp;amp;=\frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial a_{122}} + \frac{\partial J}{\partial z_{12}}\frac{\partial z_{12}}{\partial a_{122}} + \frac{\partial J}{\partial z_{21}}\frac{\partial z_{21}}{\partial a_{122}} + \frac{\partial J}{\partial z_{22}}\frac{\partial z_{22}}{\partial a_{122}}
\\
&amp;amp;=\delta_{z_{11}} \cdot w_{122} + \delta_{z_{12}} \cdot w_{121} + \delta_{z_{21}} \cdot w_{112} + \delta_{z_{22}} \cdot w_{111}
\end{aligned}
$$
泛化之后可以知道第一个channel的梯度只与第一个kernel相关：
$$\delta_{out1} = \delta_{in} * W_1^{rot180} \tag{14}$$&lt;/p>
&lt;p>同样的第二个channel只与第二个kernel有关：
$$\delta_{out2} = \delta_{in} * W_2^{rot180} \tag{15}$$&lt;/p>
&lt;p>上面是计算了输入的梯度，那对于参数的梯度如何呢？我们先看简单的例子，分别对$W_{11}, W_{12}$求导，他们当然对所有的输出都有贡献，因此都是4项：
$$
\begin{aligned}
\frac{\partial J}{\partial w_{11}} &amp;amp;= \frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial w_{11}} + \frac{\partial J}{\partial z_{12}}\frac{\partial z_{12}}{\partial w_{11}} + \frac{\partial J}{\partial z_{21}}\frac{\partial z_{21}}{\partial w_{11}} + \frac{\partial J}{\partial z_{22}}\frac{\partial z_{22}}{\partial w_{11}}
\\
&amp;amp;=\delta_{z11} \cdot a_{11} + \delta_{z12} \cdot a_{12} + \delta_{z21} \cdot a_{21} + \delta_{z22} \cdot a_{22}
\end{aligned}
\tag{16}
$$
$$
\begin{aligned}
\frac{\partial J}{\partial w_{12}} &amp;amp;= \frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial w_{12}} + \frac{\partial J}{\partial z_{12}}\frac{\partial z_{12}}{\partial w_{12}} + \frac{\partial J}{\partial z_{21}}\frac{\partial z_{21}}{\partial w_{12}} + \frac{\partial J}{\partial z_{22}}\frac{\partial z_{22}}{\partial w_{12}}
\\
&amp;amp;=\delta_{z11} \cdot a_{12} + \delta_{z12} \cdot a_{13} + \delta_{z21} \cdot a_{22} + \delta_{z22} \cdot a_{23}
\end{aligned}
\tag{17}
$$
其实就相当于将用输出做卷积核对输入求卷积，公式是：
$$
\empsym{\delta_w = A * \delta_{in} \tag{18}}
$$&lt;/p>
&lt;p>最后一个问题是对bias的梯度怎么算呢？bias显然是对每一项都有贡献的，最上面的1～4有：
$$
\begin{aligned}
\frac{\partial J}{\partial b} &amp;amp;= \frac{\partial J}{\partial z_{11}}\frac{\partial z_{11}}{\partial b} + \frac{\partial J}{\partial z_{12}}\frac{\partial z_{12}}{\partial b} + \frac{\partial J}{\partial z_{21}}\frac{\partial z_{21}}{\partial b} + \frac{\partial J}{\partial z_{22}}\frac{\partial z_{22}}{\partial b}
\\
&amp;amp;=\delta_{z11} + \delta_{z12} + \delta_{z21} + \delta_{z22}
\end{aligned}
\tag{19}
$$
也就是，其为输出的梯度的和：
$$
\empsym{\delta_b = \sum \delta_{in} \tag{20}}
$$&lt;/p>
&lt;p>代码验证一下&lt;sup id="fnref:10">&lt;a href="#fn:10" class="footnote-ref" role="doc-noteref">10&lt;/a>&lt;/sup>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">conv_backward_naive&lt;/span>(dout, cache):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> A naive implementation of the backward pass for a convolutional layer.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Inputs:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> - dout: Upstream derivatives.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> - cache: A tuple of (x, w, b, conv_param) as in conv_forward_naive
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Returns a tuple of:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> - dx: Gradient with respect to x
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> - dw: Gradient with respect to w
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> - db: Gradient with respect to b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dx, dw, db &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>, &lt;span style="color:#66d9ef">None&lt;/span>, &lt;span style="color:#66d9ef">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Récupération des variables&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x, w, b, conv_param &lt;span style="color:#f92672">=&lt;/span> cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pad &lt;span style="color:#f92672">=&lt;/span> conv_param[&lt;span style="color:#e6db74">&amp;#39;pad&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stride &lt;span style="color:#f92672">=&lt;/span> conv_param[&lt;span style="color:#e6db74">&amp;#39;stride&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Initialisations&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dx &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>zeros_like(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dw &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>zeros_like(w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>zeros_like(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Dimensions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> N, C, H, W &lt;span style="color:#f92672">=&lt;/span> x&lt;span style="color:#f92672">.&lt;/span>shape
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> F, _, HH, WW &lt;span style="color:#f92672">=&lt;/span> w&lt;span style="color:#f92672">.&lt;/span>shape
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _, _, H_, W_ &lt;span style="color:#f92672">=&lt;/span> dout&lt;span style="color:#f92672">.&lt;/span>shape
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># db - dout (N, F, H&amp;#39;, W&amp;#39;)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># On somme sur tous les éléments sauf les indices des filtres&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>sum(dout, axis&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># dw = xp * dy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 0-padding juste sur les deux dernières dimensions de x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xp &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>pad(x, ((&lt;span style="color:#ae81ff">0&lt;/span>,), (&lt;span style="color:#ae81ff">0&lt;/span>,), (pad,), (pad, )), &lt;span style="color:#e6db74">&amp;#39;constant&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Version sans vectorisation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> n &lt;span style="color:#f92672">in&lt;/span> range(N): &lt;span style="color:#75715e"># On parcourt toutes les images&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> range(F): &lt;span style="color:#75715e"># On parcourt tous les filtres&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(HH): &lt;span style="color:#75715e"># indices du résultat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> j &lt;span style="color:#f92672">in&lt;/span> range(WW):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> k &lt;span style="color:#f92672">in&lt;/span> range(H_): &lt;span style="color:#75715e"># indices du filtre&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> l &lt;span style="color:#f92672">in&lt;/span> range(W_):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> c &lt;span style="color:#f92672">in&lt;/span> range(C): &lt;span style="color:#75715e"># profondeur&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dw[f,c,i,j] &lt;span style="color:#f92672">+=&lt;/span> xp[n, c, stride&lt;span style="color:#f92672">*&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>k, stride&lt;span style="color:#f92672">*&lt;/span>j&lt;span style="color:#f92672">+&lt;/span>l] &lt;span style="color:#f92672">*&lt;/span> dout[n, f, k, l]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># dx = dy_0 * w&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Valide seulement pour un stride = 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 0-padding juste sur les deux dernières dimensions de dy = dout (N, F, H&amp;#39;, W&amp;#39;)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doutp &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>pad(dout, ((&lt;span style="color:#ae81ff">0&lt;/span>,), (&lt;span style="color:#ae81ff">0&lt;/span>,), (WW&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,), (HH&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, )), &lt;span style="color:#e6db74">&amp;#39;constant&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 0-padding juste sur les deux dernières dimensions de dx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dxp &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>pad(dx, ((&lt;span style="color:#ae81ff">0&lt;/span>,), (&lt;span style="color:#ae81ff">0&lt;/span>,), (pad,), (pad, )), &lt;span style="color:#e6db74">&amp;#39;constant&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># filtre inversé dimension (F, C, HH, WW)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> w_ &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>zeros_like(w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(HH):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> j &lt;span style="color:#f92672">in&lt;/span> range(WW):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> w_[:,:,i,j] &lt;span style="color:#f92672">=&lt;/span> w[:,:,HH&lt;span style="color:#f92672">-&lt;/span>i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,WW&lt;span style="color:#f92672">-&lt;/span>j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Version sans vectorisation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> n &lt;span style="color:#f92672">in&lt;/span> range(N): &lt;span style="color:#75715e"># On parcourt toutes les images&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> range(F): &lt;span style="color:#75715e"># On parcourt tous les filtres&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(H&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>pad): &lt;span style="color:#75715e"># indices de l&amp;#39;entrée participant au résultat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> j &lt;span style="color:#f92672">in&lt;/span> range(W&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>pad):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> k &lt;span style="color:#f92672">in&lt;/span> range(HH): &lt;span style="color:#75715e"># indices du filtre&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> l &lt;span style="color:#f92672">in&lt;/span> range(WW):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> c &lt;span style="color:#f92672">in&lt;/span> range(C): &lt;span style="color:#75715e"># profondeur&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dxp[n,c,i,j] &lt;span style="color:#f92672">+=&lt;/span> doutp[n, f, i&lt;span style="color:#f92672">+&lt;/span>k, j&lt;span style="color:#f92672">+&lt;/span>l] &lt;span style="color:#f92672">*&lt;/span> w_[f, c, k, l]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#Remove padding for dx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dx &lt;span style="color:#f92672">=&lt;/span> dxp[:,:,pad:&lt;span style="color:#f92672">-&lt;/span>pad,pad:&lt;span style="color:#f92672">-&lt;/span>pad]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dx, dw, db
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="形状变换算子">形状变换算子&lt;/h3>
&lt;h4 id="pooling">Pooling&lt;/h4>
&lt;p>Pooling氛围Max和Mean两种，前者只有一个对结果有贡献，其梯度大小应该跟输出相等，后者是输出梯度的1/4，这个比较直观。&lt;/p>
&lt;h4 id="reshape">Reshape&lt;/h4>
&lt;p>直观的看，Reshape的输出只跟一个输入有关，其导数是1，大小是跟输出的Delta-out大小相同的，只是形状要变回之前的形状，所以我们要保存输入的形状即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">.&lt;/span>arange(&lt;span style="color:#ae81ff">6&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#f92672">.&lt;/span>reshape(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>reshape(&lt;span style="color:#ae81ff">6&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="permutetranspose">Permute/Transpose&lt;/h4>
&lt;p>跟Reshape一样只涉及形状的变化，不过这里要保存的是axis，通过&lt;code>argsrot&lt;/code>在permute回去就可以了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>ones((&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>axis &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>back_axis &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>argsort(axis) &lt;span style="color:#75715e"># (2, 0, 1)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#f92672">.&lt;/span>transpose(axis)&lt;span style="color:#f92672">.&lt;/span>transpose(back_axis) &lt;span style="color:#f92672">==&lt;/span> x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="sliceindex">Slice/Index&lt;/h4>
&lt;h1 id="框架分析">框架分析&lt;/h1>
&lt;p>两种实现方式：&lt;/p>
&lt;ul>
&lt;li>source code转换，可能是python转python或者C++，也可能是转换成计算图，比如Tensorflow&lt;/li>
&lt;li>运行时监控函数的执行过程，比如autograd&lt;/li>
&lt;/ul>
&lt;h2 id="autograd">autograd&lt;/h2>
&lt;p>autograd放在第一个去分析，但是其实并不建议去看它的代码，因为其基本原理非常直观，复杂的地方在于其为了利用numpy强行在其上面进行了包装和解封，所以看起来代码很多，但是其很多的细节都是在解决如何trace函数的执行的问题，也就是如何构建计算图。autograd事实上有三个大的模块：&lt;/p>
&lt;ol>
&lt;li>追踪(trace)不同primitive函数的组合: &lt;code>Node, primitive, forward_pass&lt;/code>&lt;/li>
&lt;li>为每一个primitive函数定义一个VJP函数: &lt;code>defvjp&lt;/code>&lt;/li>
&lt;li>所有的VJP反向运行: &lt;code>backward_pass, make_vjp, grad&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>为了追踪算子的执行情况，autograd的增加了两个类型，一个是Node，一个是primitive，primitive跟numpy的算法一一对应的，不过不是接收numpy.ndarray类型，而是接收Node类型的输入和输出，一个典型的加法算子如下，输入和输出是两个节点a和b，其核心计算仍然是调用numpy的算子，但是包了一层将输入的node解包之后给numpy，然后得到的结果再打包成Node的类型。注意输出节点的内容，其parent是输入节点a，反向的算子是&lt;code>autograd.numpy.sum&lt;/code>里边构建的。&lt;/p>
&lt;img src="./images/autograd-primitive.png" class="center" style="max-width: 60%;" />
&lt;p>相比而言，这两个教学类型的库就直观很多，他们简单的复刻了autograd的实现方式并不追求跟numpy的完美支持，所以逻辑看起来更清晰，但是大体步骤比较类似，一个是&lt;a href="https://github.com/mattjj/autodidact/tree/master">autodidact&lt;/a>，一个是&lt;a href="https://github.com/mblondel/teaching/tree/main/autodiff-2020">autodiff&lt;/a>。&lt;/p>
&lt;h2 id="micrograd">micrograd&lt;/h2>
&lt;p>&lt;a href="https://github.com/karpathy/micrograd">micrograd&lt;/a>应该是这几个项目中最小巧精致的，像它名字暗示的一样，它用非常简短的代码实现了一个自动求导框架，并在此基础之上实现了一个接口类似于Pytorch的神经网络库，可谓“麻雀虽小，五脏俱全”，reverse模式的自动微分，动态计算图的构建，拓扑排序一个都没有少，只不过为了简洁，算子只支持scalar类型的数据，矩阵和tensor都不支持，但是通过scalar类型的算子构建出一个完整的深度学习分类网也是很有趣了。&lt;/p>
&lt;p>&lt;code>Value&lt;/code>类型就是我们所说的基本类型，它是一个scalar，其支持&lt;code>add, mul, pow, relu&lt;/code>等基本操作，以add为例，其正向和反向代码为如下，其用了&lt;code>+=&lt;/code>是因为这个节点可能是很多其他op的输入，所以要加起来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __add__(self, other):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> other &lt;span style="color:#f92672">=&lt;/span> other &lt;span style="color:#66d9ef">if&lt;/span> isinstance(other, Value) &lt;span style="color:#66d9ef">else&lt;/span> Value(other)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out &lt;span style="color:#f92672">=&lt;/span> Value(self&lt;span style="color:#f92672">.&lt;/span>data &lt;span style="color:#f92672">+&lt;/span> other&lt;span style="color:#f92672">.&lt;/span>data, (self, other), &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">_backward&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>grad &lt;span style="color:#f92672">+=&lt;/span> out&lt;span style="color:#f92672">.&lt;/span>grad
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> other&lt;span style="color:#f92672">.&lt;/span>grad &lt;span style="color:#f92672">+=&lt;/span> out&lt;span style="color:#f92672">.&lt;/span>grad
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out&lt;span style="color:#f92672">.&lt;/span>_backward &lt;span style="color:#f92672">=&lt;/span> _backward
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> out
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>反向传播先通过拓扑排序找到依赖，然后倒序求梯度，因为是只有标量，最后一个节点的梯度就是对自身也即1:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">backward&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># topological order all of the children in the graph&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> topo &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited &lt;span style="color:#f92672">=&lt;/span> set()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">build_topo&lt;/span>(v):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> v &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#f92672">in&lt;/span> visited:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited&lt;span style="color:#f92672">.&lt;/span>add(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> child &lt;span style="color:#f92672">in&lt;/span> v&lt;span style="color:#f92672">.&lt;/span>_prev:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build_topo(child)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> topo&lt;span style="color:#f92672">.&lt;/span>append(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build_topo(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># go one variable at a time and apply the chain rule to get its gradient&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>grad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> v &lt;span style="color:#f92672">in&lt;/span> reversed(topo):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v&lt;span style="color:#f92672">.&lt;/span>_backward()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了这个简单的自动求微分过程，就可以在此基础上面实现神经网络算子了，比如&lt;code>Neuron, Layer, MLP&lt;/code>等，可以看&lt;code>nn.py&lt;/code>这个文件。&lt;/p>
&lt;p>大概19年刚出来的时候，我用c++模仿实现了一个，并用pybind11封装出来了一个python的接口，也可以训练一个简单的MLP网络，当然就是速度比较慢，代码在这里&lt;a href="https://github.com/elinx/ugrad">ugrad&lt;/a>。&lt;/p>
&lt;h2 id="tinygrad">tinygrad&lt;/h2>
&lt;p>tinygrad是geohot的作品，号称核心代码不超过1000行，但是去看的话，代码如其人，果然是充满了浓郁的不羁。抛开这些不谈，像其在首页上说的那样，它是处于micrograd和pytorch中间的库，比micrograd更强大，支持tensor数据类型，支持了甚至像stable diffusition这样比较新和复杂的模型，而且还居然支持很多的硬件，比如Apple Neural Engin和TPU，以及他们自己的硬件。但是实现明显又比pytorch小巧很多，而且支持了不少pytorch不支持的功能，值得我们仔细分析一下。&lt;/p>
&lt;p>为什么tinygrad可以如此简单呢？从tinygrad作者的言语中可以发现，其设计的初衷是为了自己设计一款加速芯片（虽然最后没有成型）&lt;sup id="fnref:11">&lt;a href="#fn:11" class="footnote-ref" role="doc-noteref">11&lt;/a>&lt;/sup>，因此更像是事先就规定了指令集一样先划定了自己要支持的op类型，然后所有复杂算子都是在这个基础之上构建。具体来说就是有下面这6种类型（之前是4种），也就是作者所说的&lt;code>llops&lt;/code>，也即low level ops：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># these are the llops your accelerator must implement, along with toCpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UnaryOps &lt;span style="color:#f92672">=&lt;/span> Enum(&lt;span style="color:#e6db74">&amp;#34;UnaryOps&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;NOOP&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;NEG&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;RELU&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;EXP&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;LOG&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SIGN&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;RECIPROCAL&amp;#34;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BinaryOps &lt;span style="color:#f92672">=&lt;/span> Enum(&lt;span style="color:#e6db74">&amp;#34;BinaryOps&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;ADD&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SUB&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;MUL&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;DIV&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;POW&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;CMPEQ&amp;#34;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ReduceOps &lt;span style="color:#f92672">=&lt;/span> Enum(&lt;span style="color:#e6db74">&amp;#34;ReduceOps&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;SUM&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;MAX&amp;#34;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MovementOps &lt;span style="color:#f92672">=&lt;/span> Enum(&lt;span style="color:#e6db74">&amp;#34;MovementOps&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;RESHAPE&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;PERMUTE&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;EXPAND&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;FLIP&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;STRIDED&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;PAD&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;SHRINK&amp;#34;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ProcessingOps &lt;span style="color:#f92672">=&lt;/span> Enum(&lt;span style="color:#e6db74">&amp;#34;ProcessingOps&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;CONV&amp;#34;&lt;/span>]) &lt;span style="color:#75715e"># new&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoadOps &lt;span style="color:#f92672">=&lt;/span> Enum(&lt;span style="color:#e6db74">&amp;#34;LoadOps&amp;#34;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#34;FROMCPU&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;CONTIGUOUS&amp;#34;&lt;/span>]) &lt;span style="color:#75715e"># new&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在这个之上封装了一层middle level ops，也就是&lt;code>mlops&lt;/code>，这个就是利用&lt;code>llops&lt;/code>实现的pytorch算子，包括正向和反向两个部分，比如&lt;code>relu, log, sum, max, reshape, Conv2D&lt;/code>等，看一个&lt;code>Sum&lt;/code>的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Sum&lt;/span>(Function):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">forward&lt;/span>(self, x, axis&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>input_shape &lt;span style="color:#f92672">=&lt;/span> x&lt;span style="color:#f92672">.&lt;/span>shape
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x&lt;span style="color:#f92672">.&lt;/span>reduce_op(ReduceOps&lt;span style="color:#f92672">.&lt;/span>SUM, reduce_shape(x&lt;span style="color:#f92672">.&lt;/span>shape, axis))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">backward&lt;/span>(self, grad_output):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> grad_output&lt;span style="color:#f92672">.&lt;/span>movement_op(MovementOps&lt;span style="color:#f92672">.&lt;/span>EXPAND, self&lt;span style="color:#f92672">.&lt;/span>input_shape)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如何构建计算图？
如何支持很多的加速硬件？
&lt;code>shape tracker&lt;/code>有什么作用？
什么是&lt;code>lazy ops&lt;/code>?&lt;/p>
&lt;h2 id="jax">jax&lt;/h2>
&lt;h2 id="pytorch">pytorch&lt;/h2>
&lt;h2 id="tensorflow">tensorflow&lt;/h2>
&lt;h1 id="性能改进探讨">性能改进探讨&lt;/h1>
&lt;h1 id="动手实现一个">动手实现一个&lt;/h1>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Linear_approximation">Linear approximation. (2021, November 28). In Wikipedia.&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Jake VanderPlas. Python Data Science Handbook, Computation on Arrays: Broadcasting&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&lt;a href="https://ajcr.net/stride-guide-part-2/">An Illustrated Guide to Shape and Strides (Part 2)&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>&lt;a href="https://explained.ai/matrix-calculus/">The Matrix Calculus You Need For Deep Learning&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>&lt;a href="https://vaipatel.com/how-is-the-vector-jacobian-product-invoked-in-neural-odes/">How Is The Vector-Jacobian Product Invoked In Neural ODEs&lt;/a>&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>&lt;a href="https://web.stanford.edu/class/cs224n/readings/gradient-notes.pdf">Computing Neural Network Gradients&lt;/a>&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7">
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/24709748">矩阵求导术（上）&lt;/a>&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8">
&lt;p>&lt;a href="https://www.radx.in/jax.html">Understanding Autodiff with Jax&lt;/a>&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:9">
&lt;p>&lt;a href="https://microsoft.github.io/ai-edu/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC8%E6%AD%A5%20-%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/17.3-%E5%8D%B7%E7%A7%AF%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%8E%9F%E7%90%86.html">卷积的反向传播原理&lt;/a>&amp;#160;&lt;a href="#fnref:9" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:10">
&lt;p>&lt;a href="https://towardsdatascience.com/backpropagation-in-a-convolutional-layer-24c8d64d8509">Backpropagation in a convolutional layer&lt;/a>&amp;#160;&lt;a href="#fnref:10" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:11">
&lt;p>&lt;a href="https://geohot.github.io/blog/jekyll/update/2021/06/13/a-breakdown-of-ai-chip-companies.html">A Breakdown of AI Chip Companies&lt;/a>&amp;#160;&lt;a href="#fnref:11" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content></item></channel></rss>